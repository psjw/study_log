# 📘 인프런 - Spring WebFlux + LLM 실전 구현


## 📅 2025-07-21 - 리액티브 프로그래밍이란?

### 💡 학습 주제

- Spring WebFlux란 무엇인지 이해
- 리액티브 프로그래밍 개념과 필요성 학습


### 🧠 주요 개념 요약


| 항목 | 설명 |
|------|------|
| **WebFlux** | 비동기 논블로킹 I/O를 기반으로 하는 Spring의 웹 프레임워크. Netty, Undertow 등 Servlet이 아닌 웹서버와 통합 가능. |
| **리액티브 서비스** | 요청이 발생했을 때 자원을 효율적으로 활용해 빠르게 반응하는 비동기 서비스. 사용자 경험 개선과 시스템 자원 절약에 유리. |
| **동기/블로킹 방식** | 예: Tomcat. 요청-응답 구조에서 I/O가 끝날 때까지 스레드가 차단됨. |
| **비동기/논블로킹 방식** | 예: Netty. 요청 후 OS에 콜백을 등록하고 다른 작업 수행. 응답 도착 시 이벤트 루프(Selector)가 처리. |
| **WebFlux의 장점** | - Netty 기반 논블로킹 I/O 지원<br> - Flux/Mono를 통한 리액티브 스트림 기반<br> - WebClient, R2DBC와의 자연스러운 통합<br> - 이벤트 기반으로 Stream 통신 구현 가능 |


### 🆚 생활 비유로 이해하는 비동기/논블로킹 모델

> 치킨 배달 상황을 통해 동기/비동기 방식을 비교해 보자.

#### 🧍 동기 블로킹 방식 (Tomcat 등)

- 당신이 치킨을 시킨 후, 문 앞에서 치킨이 올 때까지 아무 일도 하지 않고 기다린다.
- 이 방식은 치킨(I/O)이 도착할 때까지 **스레드가 아무 작업도 하지 못한 채 대기**하는 구조다.

#### 🏃 비동기 논블로킹 방식 (Netty 등)

- 당신은 치킨을 시킨 후, 어머니에게 "치킨이 오면 메모 좀 남겨줘"라고 말하고 다른 일을 하러 간다.
- 어머니는 거실(커널 영역)에서 치킨이 오면 메모(이벤트)를 남긴다.
- 당신은 나중에 메모를 확인하고 문을 연다.

> 📝 비유 요약  
> 방 = 프로세스  
> 사람 = 스레드  
> 치킨 시키기 = I/O 요청  
> 어머니 = OS (이벤트 감지자)  
> 거실 = 커널 영역  
> 메모 확인 = 이벤트 루프(Selector)를 통한 이벤트 조회 및 실행
>> ### 💡 이처럼 WebFlux는 치킨 배달 예시의 **비동기 논블로킹 방식**과 같은 구조를 가지며, 자원을 효율적으로 사용하고 높은 확장성을 제공




### 🧪 실습 코드



#### 📌 1. 전통적 동기 방식

```java
List<Integer> sink = new ArrayList<>();
for (int i = 1; i < 10; i++) {
    Thread.sleep(500); // 0.5초 지연
    sink.add(i);
}
```

#### 📌 2. 리액티브 방식 (Flux 사용)

> 클라이언트 요청 헤더에 `Accept: text/event-stream` 추가  
> (요구사항: 데이터가 생성될 때마다 스트리밍으로 응답)

```java
Flux.create(sink -> {
    for (int i = 1; i < 10; i++) {
        try {
            Thread.sleep(500); // ⚠️ 블로킹 코드 (실습 목적)
        } catch (InterruptedException e) {
            sink.error(e);
        }
        sink.next(i);
    }
    sink.complete();
});
```


> 위 코드에서 `Thread.sleep()`은 실제 리액티브 환경에서는 사용 지양  
> `Mono.delay()`, `Flux.interval()` 등을 사용하여 논블로킹 처리할 것


### 🔎 리액티브 프로그래밍 핵심 포인트

1. **리액티브 스트림 사용 (Flux/Mono)**  
   - 데이터를 스트림 형태로 비동기 전송  
   - 준비된 데이터부터 순차적으로 전송 가능  
   - `text/event-stream` 으로 실시간 스트리밍 처리 가능

2. **논블로킹 프로그래밍 필수**  
   - 모든 연산 흐름이 블로킹 없이 연결되어야 함  
   - Netty의 이벤트 루프 모델 기반으로 설계  
   - `Thread.sleep()`, JDBC 등의 블로킹 API 사용은 금물  
   - R2DBC, WebClient, Schedulers 등을 통한 완전한 비동기화 필요

3. **함수형 스타일**  
   - 선언형, 체이닝 기반의 연산 (`map`, `flatMap`, `filter`, `zip`)  
   - side-effect 최소화


### 🧾 마무리

- Spring WebFlux는 Netty 기반으로 작동하며 논블로킹 서비스 구축에 특화됨
- Flux, Mono를 통해 데이터를 스트리밍 방식으로 전달하며, 효율적인 자원 관리 가능
- 리액티브 시스템은 비동기 흐름과 함수형 스타일이 핵심이며, 블로킹 코드를 철저히 배제해야 함
---


## 📅 2025-07-21 - 스레드란?

### 💡 학습 주제

- 스레드의 개념과 역할 이해
- Tomcat과 Netty의 스레드 처리 방식 비교


### 🧠 주요 개념 요약


| 항목 | 설명 |
|------|------|
| **Thread** | 하나의 작업흐름을 실행시켜 주는것 - 작성한 코드를 포함한 애플리케이션의 작업흐름을 실행 |
| **Thread의 흐름** | 사용자 요청 -> CPU 자원할당 -> 웹서버 -> 작성 코드 실행 =? 사용자에게 응답 |
| **Tomcat Thread의 흐름** | 사용자 요청 수락(네트워크I/O) -> 요청 읽기(네트워크 I/O) -> 작성 코드 수행 -> 응답 쓰기 -> 사용자에게 응답 전송(네트워크 I/O) |
| **Netty Thread의 흐름** | 사용자 요청 수락 -> 이벤트 루프(네트워크 I/O는 OS에게)-> 요청 읽기(네트워크 I/O) -> 이벤트 루프(네트워크 I/O는 OS에게)-> 작성 코드 수행 -> 이벤트 루프 -> 응답 쓰기 -> 이벤트 루프-> 사용자에게 응답 전송(네트워크 I/O) -> 이벤트 루프(네트워크 I/O는 OS에게)  |



### 🆚 톰캣 vs Netty

#### 🧍 톰캣 스레드 모델

> Tomcat은 요청마다 스레드를 생성하여 작업을 처리하는 전통적 구조

- 요청 수락 → 요청 읽기 → 비즈니스 로직 실행 → 응답 쓰기를 모두 **동일한 스레드**에서 처리
- 블로킹 I/O 기반이며, 작업 중 대기 시간이 발생해도 스레드가 점유됨
- 다수의 요청을 처리하기 위해 **수백 개의 스레드**를 유지함

#### 🏃 Netty 스레드 모델

> Netty는 이벤트 루프 기반으로 작동하며, 비동기 논블로킹 방식에 최적화되어 있음

- 요청을 수락한 후 I/O 작업은 OS에 위임 (Selector를 통한 비동기 I/O)
- 작성한 코드만 간단히 실행한 뒤 다시 이벤트 루프로 복귀
- **작은 수의 스레드**로도 수천, 수만 개의 요청 처리 가능
- 컨텍스트 스위칭 비용 절감

| 구분 | Tomcat | Netty |
|------|--------|-------|
| 스레드 모델 | 요청당 1스레드 | 이벤트 루프 기반, 소수 스레드 |
| 블로킹 허용 | 일정 허용 | 거의 불가 |
| 스레드 수 | 수백 개 이상 | CPU 코어 수와 동일 수준 |
| 특징 | 직관적 구조, 자원 소모 많음 | 고성능 구조, 논블로킹 코드 필수 |



### ❓ 의문사항 정리

#### 📌 Q1. Netty도 스레드를 많이 만들면 안 되나요?

```
[ 하드웨어 영역(CPU) | 커널 영역(OS) | 유저 영역(프로세스) ]
```

- CPU는 **작업할 스레드의 컨텍스트**를 캐시에 올려두고 처리
- 스레드가 많아질수록 **캐시 교체와 컨텍스트 스위칭 비용**이 증가
- Netty는 CPU 코어 수만큼 스레드를 유지하여 **스위칭 비용을 최소화**

#### 📌 Q2. CPU가 한정되어 있는데, 애플리케이션은 어떻게 수많은 스레드를 만들 수 있나요?

- CPU 코어는 일반적으로 **1개의 물리적 스레드**를 동시 처리
- 우리가 생성하는 대부분의 스레드는 **논리 스레드**이며, 실제 실행은 **OS 스케줄러**가 관리
- CPU는 여러 논리 스레드 중 하나씩 교대로 실행 → **동시성이 아닌 시분할 처리**
- 프로세스는 스레드 수에 신경 쓸 필요 없이 OS가 적절히 할당


---

### 🔎 스레드 핵심 포인트

1. **스레드**는 프로그램의 실행 흐름 단위이며, 동시성의 기본 단위
2. **Tomcat**은 요청당 스레드를 할당하고, 블로킹을 수용할 수 있는 구조
3. **Netty**는 이벤트 루프를 통해 소수의 스레드로도 대량의 요청을 비동기 처리한
4. **스레드는 논리적 개념**이며, 실제 실행은 OS가 물리 CPU 코어에 맞게 스케줄링
5. **스레드 수가 많을수록 컨텍스트 스위칭 비용**이 증가하므로, Netty는 효율성을 위해 소수 스레드 유지 전략을 사용



---
### 🧾 마무리

- Tomcat은 직관적이고 사용하기 쉬우나, 대규모 동시 요청 처리에 비효율적
- Netty는 논블로킹 I/O 및 이벤트 기반 처리로 고성능 서버 개발에 적합하지만, **블로킹 코드를 섞으면 성능이 치명적으로 저하됨**.
- 고성능 백엔드 서버를 구축하려면 Netty와 같은 이벤트 루프 기반의 구조를 이해하고, 비동기 프로그래밍 방식에 익숙해질 필요가 있음

---
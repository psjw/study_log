# 🧠 제어장치

### ✅ 핵심 개념 요약
- 클럭 신호를 기준으로 연산과 제어 흐름을 동기화
- 명령어 레지스터(IR)에서 Opcode를 추출하고 해석
- 플래그 레지스터의 상태를 읽어 조건 분기를 판별
- 제어 버스를 통해 ALU, 레지스터, 메모리, 입출력 장치로 제어 신호를 전송

---

### 🔎 JIT 인라이닝과 제어장치의 관계

|       항목                 | 설명                                                          |
|---------------------------|------------------------------------------------------------|
| JIT 인라이닝    | 메서드 호출을 실제 코드로 펼쳐 제어 흐름을 단순화                             |
| 제어장치 영향  | 명령어 파이프라인은 동시 처리 방식이나, 런타임에 참조 메모리 주소가 결정될 경우 파이프라인이 무효화되어 재시작됨 → 성능 저하 발생 |
| 성능 이점     | 분기 예측 실패 위험 감소, 캐시 라인 접근 예측성 증가                              |

---

### 🔎 분기 예측과 바이트 코드

- `invokevirtual`: 다형성 상황에서 실행 대상이 런타임에 결정됨 → 간접 분기로 인식
- CPU는 해당 간접 분기에 대해 분기 예측을 수행하며, 실패 시 성능 저하 발생
- 명령어 파이프라인을 통해 동시 처리를 진행하는데 런타임시 결정되는 메모리주소 참조로 인해 파이프라인이 무효화(flush)되어 재시작(restart)됨


```java
Person p = new Student(); 
if (x > 0) p.study();  // invokevirtual: 런타임에 대상 메서드 결정
```

### 요약 흐름도
```txt
|     명령어 레지스터 (IR)          |
|   + 플래그 레지스터(조건 플래그)     |
+---------------+---------------+
                |
                v
+-----------------------------------+
|           제어 장치 (CU)            |
|  - Opcode 해석                     |
|  - 플래그 값 판별                  |
|  - 제어 신호 생성                  |
+-----------------------------------+
                |
                v
+-----------------+-----------------+--------------------+---------------------+
|     ALU         |     레지스터     |     메모리          |     입출력 장치       |
| (산술/논리 연산)   | (데이터 저장)    | (명령어/데이터 접근)   | (I/O 제어 신호 전송)  |
+-----------------+-----------------+--------------------+---------------------+
```

### 📌 메서드 인라이닝 (JIT 최적화)
✅ 전
```java
void process() {
    validate(); // 메서드 A
    save();     // 메서드 B
}

```

✅ 후 (JIT 인라이닝 적용)
```java
void process() {
    // validate()의 실제 코드 복사
    if (param == null) throw ...
    
    // save()의 실제 코드 복사
    db.insert(record);
}
```
➕ 추가 예시
```java
public int add(int a, int b) { return a + b; }

int x = add(1, 2); 
// → JIT 인라이닝 후: int x = 1 + 2;
```


### 🔁 회고
- JVM의 JIT 인라이닝 최적화는 메서드 호출을 제거하고 실제 코드를 펼침으로써, 제어장치가 별도의 분기 예측 없이 순차적으로 명령어를 실행
- 이는 프로그램 카운터의 선형 증가로 처리 가능하게 하여, 파이프라인 효율과 명령어 캐시 일관성(Cache Hit Ratio)을 높이는 데 기여
- 바이트코드 상의 `invoke*` 계열 명령은 하드웨어 분기 예측 로직과 밀접한 관계가 있으며, 이를 소스 코드 수준에서 최적화하는 것이 JVM 튜닝에서도 매우 중요한 포인트임을 인지함
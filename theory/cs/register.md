#  🧠 Register - 레지스터와 JVM 실행 구조


### ✅ 핵심 개념 요약
- **레지스터(Register)**는 CPU 내부의 초고속 임시 저장소로, 모든 연산은 반드시 레지스터를 통해 수행
- Java는 JVM 위에서 실행되며 바이트코드를 **스택 기반**으로 처리하지만, JIT(Just-In-Time) 컴파일 이후에는 **레지스터 기반 기계어로 변환되어 CPU에서 실행**

---

### 🔎 상세 개념 정리

| 레지스터명 | 설명 |
|------------|------|
| **Program Counter (PC)** | 다음에 실행할 명령어의 메모리 주소를 저장 |
| **Instruction Register (IR)** | 현재 실행 중인 명령어 자체를 저장 |
| **Memory Address Register (MAR)** | 메모리 접근 시 주소 값을 저장 |
| **Memory Data Register (MDR)** | 메모리와 주고받는 데이터 값 저장 |
| **Flag Register** | 연산 결과 상태 정보 저장 (Zero, Carry, Overflow 등) |
| **General-purpose Register** | 범용 연산 및 임시 데이터 저장 (예: eax, ebx 등) |
| **Stack Pointer (SP)** | 현재 스택 프레임의 최상위 주소를 가리킴 |
| **Base Register** | 기준 주소를 저장하여 변위 주소 계산에 사용됨 |

---


### ✅  JVM과 레지스터의 관계

#### 🔹 JVM은 스택 기반, JIT은 레지스터 기반


| 항목 | 설명 |
|------|------|
| **JVM 바이트코드 실행** | `iload`, `iadd` 등의 명령은 **스택 기반**으로 실행됨 |
| **JIT 컴파일러** | 바이트코드를 분석하여 **레지스터 기반 기계어**로 변환 |
| **실행** | 최적화된 기계어는 CPU에서 **레지스터를 활용하여 직접 실행**됨 |

> 📌 JVM은 기본적으로 스택 기반이지만, JIT 컴파일 이후에는 실제로 **레지스터 기반 명령어로 실행**됩니다.


---

### ✅  레지스터와 Java 동시성/성능의 관계

#### 🔹 동시성과 Memory Barrier

| 개념 | 설명 |
|------|------|
| **`volatile`** | 캐시/레지스터 값을 메인 메모리로 강제 flush → **메모리 일관성 보장** |
| **`synchronized`** | 락 획득/해제 시 메모리와 레지스터 간 동기화 발생 → **올바른 동시성 보장** |

####🔹 GC와 레지스터

| 항목 | 설명 |
|------|------|
| **GC 시점 레지스터 추적** | Stop-the-world GC 발생 시 레지스터에 있는 **객체 참조도 추적**해야 함 |
| **OopMap** | 어떤 레지스터에 어떤 객체가 있는지 GC가 추적할 수 있도록 기록한 **메타데이터** |
---


### ✅  바이트코드 → 레지스터 예시

#### 🔹 Java 코드
```java
int a = 2;
int b = 3;
int c = a + b;
```

#### 🔹 JVM 바이트코드
```
iconst_2      // 2를 스택에 push
istore_1      // 로컬 변수 a에 저장
iconst_3
istore_2
iload_1
iload_2
iadd
istore_3
```
#### 🔹 JIT 컴파일 이후 (x86 어셈블리 예)
```
mov eax, 2
mov ebx, 3
add eax, ebx
```
> 🔧 바이트코드는 JVM에서 스택 기반으로 실행되지만, JIT 컴파일러가 기계어로 변환하면서 레지스터 기반으로 최적화 됨
---

### 🔁 회고

- JVM은 스택 기반 바이트코드를 실행하지만, 성능 최적화를 위해 HotSpot JIT 컴파일러가 동작하면 해당 바이트코드를 레지스터 기반 기계어로 변환
- 이 과정에서 CPU는 레지스터를 직접 활용하여 연산을 수행하며, 이를 통해 실행 속도가 크게 향상
- GC 시에는 JIT 컴파일된 코드에 의해 레지스터에 저장된 객체 참조 정보를 OopMap으로 관리하여 정확한 GC 수행이 가능해짐

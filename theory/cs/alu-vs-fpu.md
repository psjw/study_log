#  🧠 ALU VS FPU

### ✅ 핵심 개념 요약
- CPU 연산 장치는 ALU(정수)와 FPU(실수)로 나뉨
- 부동소수점 연산의 정확도 한계로 인해 Java에서는 `BigDecimal`을 사용해 정밀 연산을 수행

### 🔎 상세 개념 정리
| 항목                  | 설명                                                                 |
|-----------------------|----------------------------------------------------------------------|
| **실수의 2진수 변환** | 정수부는 `/2`, 소수부는 `×2` 방식으로 이진수 변환 수행 |
| **무한소수** | 예: 0.3 → 이진수로 끝나지 않아 정확한 표현 불가 → 누적 오차 발생 |
| **고정소수점** | 정수/소수 고정 위치로 표현 → 표현 범위 제한, 메모리 낭비 가능 |
| **부동소수점 (IEEE 754)** | 1bit 부호 + 8bit 지수 + 23bit 가수 (예: 118.625 → 정규화 → 지수 + 가수 분리 저장) |
| **BigDecimal** | 18자리 이상 정밀도가 필요할 때 사용. 정수부 + scale(소수점 위치)로 구성, 다만 속도는 느림 |

### 📘 부동소수점 시나리오 (예: `118.625` → IEEE 754 32bit)
```
입력 실수: 118.625
↓
정수부 118 → 1110110 (이진수)
소수부 0.625 → .101 (이진수)
↓
결합 → 1110110.101
↓
정규화 → 1.110110101 × 2^6
↓
지수 + Bias(127) = 6 + 127 = 133 → 10000101 (8bit)
가수 = 11011010100000000000000 (23bit로 절삭)
↓
최종 IEEE 754 32bit 표현 = [0][10000101][11011010100000000000000]
```
### 🔁 회고

- 금융권 재직 당시 `BigDecimal`을 기본 타입으로 사용했으며,  부동소수점의 정밀도 한계와 그 해결책에 대한 이해가 부족했음을 깨달음.  
- 이번 학습을 통해 **정규화 개념과 IEEE 754 구조**를 명확하게 이해하게 되었음.

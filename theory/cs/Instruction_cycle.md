#  🧠 명령어 사이클


### ✅ 핵심 개념 요약
- CPU는 프로그램 실행 시 기본적으로 `Fetch → Decode → Execute` 순서를 반복하는데, 이를 **명령어 사이클**이라 함.
- 고급 프로세서에서는 `Memory Access`, `Write Back` 등의 단계가 추가될 수 있음.
- JVM도 내부적으로 유사한 처리 구조를 따르며, JIT 컴파일 시 실제 CPU 명령어 사이클과 동일하게 동작함.
---

### 🔎 상세 개념 정리

| 명령어 | 설명 |
|------------|------|
| **Fetch (인출)**         | 프로그램 카운터(PC)에 지정된 명령어 주소로부터 명령어를 메모리에서 읽어와 `명령어 레지스터(IR)`에 저장 |
| **Decode (해석)**        | 제어 장치(Control Unit)가 IR에 저장된 **Opcode**를 해석하여 어떤 연산을 수행할지 결정 |
| **Execute (실행)**       | ALU 또는 FPU가 실제 연산을 수행 (산술/논리/비교 등) |
| **Memory Access (메모리 접근)** | 명령이 Load/Store일 경우, 해당 주소의 데이터를 메모리에서 읽거나 씀 |
| **Write Back (결과 저장)** | 연산 결과를 레지스터 또는 메모리에 저장 |

---


### ✅  CPU 명령어 사이클  vs JVM 바이트 코드
| 단계           | CPU 명령어 사이클                            | JVM 내부 처리 흐름                                       |
|----------------|---------------------------------------------|----------------------------------------------------------|
| **Fetch**       | 명령어를 메모리에서 읽어와 IR에 저장               | 바이트코드를 메서드 영역(Method Area)에서 읽어옴         |
| **Decode**      | 제어 장치가 Opcode 해석                         | **인터프리터 또는 JIT**가 Opcode 해석                         |
| **Execute**     | ALU/FPU를 통한 연산 수행                        | **스택 기반 연산**, 메서드 호출, 필드 접근 등 수행               |
| **Memory Access** | 명령에 따라 메모리에서 값 Load/Store 수행         | 힙(Heap), 메서드 영역 접근 또는 객체 필드 접근                   |
| **Write Back**  | 결과를 레지스터나 메모리에 저장                   | 스택 프레임(Stack Frame)에 연산 결과 저장                    |


---

### ✅ 예시 흐름 (JVM 기준)
```java
int sum(int a, int b) {
    return a + b;
}
```
#### ➡ 바이트코드로 변환:
```
0: iload_1       // a를 스택에 로드
1: iload_2       // b를 스택에 로드
2: iadd          // 스택 위 두 값을 더함
3: ireturn       // 결과 반환
```
#### ➡ 명령어 사이클 (JVM):
1. Fetch: 바이트코드 iload_1를 메서드 영역에서 가져옴
2. Decode: iload_1 명령 해석
3. 	Execute: 로컬 변수 슬롯 1번의 값을 스택에 푸시
---

### 🔁 회고

- 명령어 사이클은 하드웨어(CPU)와 소프트웨어(JVM) 모두에서 제어 흐름과 실행 구조의 핵심 개념
- JVM은 CPU의 명령어 사이클과 유사하게 구성되어 있으며, JIT 컴파일 후에는 실제 CPU 명령어 사이클로 실행됨

#  🧠 알고리즘  - 위상 정렬 (Topological Sort)


## ✅ 핵심 개념 요약


- **위상 정렬**은 싸이클이 없는 방향 그래프(DAG, Directed Acyclic Graph)에서 **노드의 선후 관계를 정렬**하는 알고리즘
- **시간 복잡도**는 O(V + E)이며, V는 노드 수, E는 간선 수를 의미
- 위상 정렬의 결과는 **항상 유일하지 않으며**, 입력 그래프에 따라 여러 정답이 존재할 수 있음



## 🔎 상세 개념 정리
| 항목 | 설명 |
|------|------|
| **진입 차수 배열** | 각 노드로 들어오는 간선의 개수를 저장하는 배열 |
| **진입 차수가 0인 노드** | 위상 정렬의 시작점이 되며, 큐에 삽입되어 탐색이 진행됨 |
| **정렬 과정** | 큐에서 노드를 꺼내고, 해당 노드가 가리키는 노드들의 진입 차수를 1씩 감소시킴. 감소 후 진입 차수가 0이 되면 큐에 추가됨 |




## 💻 실습 예시 코드 및 시각화

### 📌 1. 그래프 구조
```
1 → 2, 3
2 → 4, 5
3 → 4
4 → 5
5 → (종점)
```

---

### 📌 2. 초기 진입 차수 배열

| 노드 번호       | 1 | 2 | 3 | 4 | 5 |
|----------------|---|---|---|---|---|
| `indegree[]`   | 0 | 1 | 1 | 2 | 2 |
---

### 📌 3. 위상 정렬 진행 예시

#### 1단계: 진입 차수 0인 1을 큐에 삽입
Queue: [1]

#### 2단계: 1을 꺼내고, 연결된 노드 2, 3의 진입 차수를 1씩 감소

| 노드 번호       | 1 | 2 | 3 | 4 | 5 |
|----------------|---|---|---|---|---|
| `indegree[]`   | 0 | 0 | 0 | 2 | 2 |
Queue: [2, 3]

#### 3단계: 2 → 4, 5 / 3 → 4 처리하면서 진입 차수 업데이트

| 노드 번호       | 1 | 2 | 3 | 4 | 5 |
|----------------|---|---|---|---|---|
| `indegree[]`   | 0 | 0 | 0 | 0 | 0 |
Queue: [4, 5]
→ 모든 노드를 큐에서 꺼내면 위상 정렬 완료
---


## 📌 4. 위상 정렬 구현 코드 예시

```java
int[] indegree = new int[N + 1];
ArrayList<Integer>[] graph = new ArrayList[N + 1];
for (int i = 1; i <= N; i++) {
    graph[i] = new ArrayList<>();
}

// 간선 입력
for (int i = 0; i < E; i++) {
    int s = sc.nextInt();  // 시작 노드
    int e = sc.nextInt();  // 도착 노드
    graph[s].add(e);
    indegree[e]++;
}

```




## 🔁 회고
- 위상 정렬은 사이클이 없는 방향 그래프(DAG) 에서 노드 간의 순서를 정하는 데 매우 유용
- 큐를 사용한 Kahn’s Algorithm 방식은 직관적이며 효율적
- 진입 차수 배열을 활용하여 정렬 순서를 유도하고,
사이클 여부도 위상 정렬 결과의 길이가 전체 노드 수보다 작을 경우 감지할 수 있음
- 위상 정렬은 작업 순서 결정, 과목 선수 조건 처리, 컴파일 종속성 분석 등에 활용

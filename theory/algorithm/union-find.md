#  🧠 알고리즘  - Union-Find (Disjoint Set)

## ✅ 핵심 개념 요약

- **유니온 파인드**(Union-Find)는 여러 노드가 있을 때, 두 노드를 연결하여 하나의 집합으로 합치거나  두 노드가 **같은 집합에 속해 있는지 확인**하는 연산을 수행하는 자료구조
- `union(a, b)`는 두 노드를 하나의 그룹으로 묶고,  `find(x)`는 노드가 속한 그룹의 **대표 노드**(루트)를 반환


## 🔎 상세 개념 정리
| 항목 | 설명 |
|------|------|
| **대표노드 저장 배열** | 각 노드의 부모(대표 노드)를 저장하는 배열로, 처음에는 자기 자신이 대표 노드 |
| **union 연산** | 두 노드의 대표 노드를 찾아 하나로 합친다. 합쳐진 후에는 하나의 루트만 가리킴 |
| **find 연산** | 해당 노드의 대표 노드를 찾는 재귀 함수. 경로 압축(Path Compression)을 적용하여 성능을 높임. |
| **find 작동 원리** | 현재 노드가 자신의 부모가 아니면 재귀적으로 대표 노드를 찾아 올라간 뒤, 중간 노드들도 모두 대표 노드로 갱신한 |
| **재방문 가능** | 같은 집합(대표 노드가 동일)이라면 언제든지 이동(재방문) 가능하다는 의미로 해석 |



## 💻 실습 예시 코드 및 시각화

### 📌 1. 대표 노드 배열 초기화

| 노드 번호  | 1 | 2 | 3 | 4 | 5 | 6 |
|------------|---|---|---|---|---|---|
| parents[]  | 1 | 2 | 3 | 4 | 5 | 6 |

---

### 📌 2. `union(1, 4)` 수행 후

| 노드 번호  | 1 | 2 | 3 | 4 | 5 | 6 |
|------------|---|---|---|---|---|---|
| parents[]  | 1 | 2 | 3 | 1 | 5 | 6 |


---

### 📌 3. `union(4, 6)` 수행 후 (`find(4)`, `find(6)` → 경로 압축 적용됨)

| 노드 번호  | 1 | 2 | 3 | 4 | 5 | 6 |
|------------|---|---|---|---|---|---|
| parents[]  | 1 | 2 | 3 | 1 | 5 | 1 |
---



### 📌 4. Union-Find 기본 구현 예시

```java
//1. 대표노드 초기화
int parents[] = new int[N+1];
for(int i =1 ; i <= N ;i++){
    parents[i] = i;
}

//2. uinon 메서드 호출
void union(int s, int e){
    int a = find(s);
    int b = find(e);
    if(a != b){
        parents[a] = b;
    }
}

int find(int i){
    if(parents[i]  == i ){
        return i;
    }

    int parent = find(i);
    parents[i] = parent;
    return parent;
}
```




## 🔁 회고
- 유니온 파인드는 서로 연결된 노드들을 그룹화하여 같은 집합인지 여부를 빠르게 판별하는 데 매우 유용
- find() 연산에 경로 압축을 적용하면 시간 복잡도가 거의 O(1)에 수렴하여 매우 빠른 성능을 기대할 수 
- 최소 신장 트리(Kruskal), 사이클 판별, 연결성 판별 등 다양한 그래프 문제에서 핵심 도구로 사용

#  🧠 알고리즘  - 플로이드-워셜 (Floyd-Warshall)

## ✅ 핵심 개념 요약

- **플로이드-워셜 알고리즘**은 **모든 노드 쌍 간의 최단 경로**를 구하는 알고리즘
- **음수 가중치**가 있어도 사용 가능하지만, **음수 사이클은 허용되지 않음**
- **동적 계획법(DP)** 을 기반으로 작은 문제부터 점차 확장해가는 방식
- 간선 수보다 **노드 수가 적은 경우 (V ≤ 100~200)** 에 적합

---

## 🔎 상세 개념 정리

| 항목 | 설명 |
|------|------|
| **초기화** | D[i][i] = 0, 그 외 D[i][j] = ∞ (도달 불가) |
| **입력 처리** | 직접 연결된 간선의 거리만 먼저 입력 |
| **점화식** | `D[S][E] = min(D[S][E], D[S][K] + D[K][E])` |
| **시간 복잡도** | O(V³) |
| **음수 사이클** | 존재 시 잘못된 결과를 반환하므로 별도 확인 필요 |

---


## 🧠 플로이드-워셜 알고리즘 동작 흐름

1. **2차원 배열 D[][] 초기화**  
   → 자기 자신은 0, 나머지는 ∞  
2. **간선 입력으로 거리 설정**  
   → `D[start][end] = weight`  
3. **모든 노드 K를 경유지로 삼아 갱신**  
   → `for k → for i → for j` 순서의 3중 for문  
   → `D[i][j] = min(D[i][j], D[i][k] + D[k][j])`

---

## 💻 실습 예시 코드 및 시각화

### 📌 플로이드-워셜 알고리즘 로직 예시
```java
for (int k = 1; k <= N; k++) {
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            if (dist[i][k] != INF && dist[k][j] != INF) {
                dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }
}
```

---

## 🧪 예시 시각화

### 📌 초기 상태 (자기 자신 0, 나머지 ∞)

| S/E | 1 | 2 | 3 | 4 | 5 |
|------|---|---|---|---|---|
| 1 | 0 | ∞ | ∞ | ∞ | ∞ |
| 2 | ∞ | 0 | ∞ | ∞ | ∞ |
| 3 | ∞ | ∞ | 0 | ∞ | ∞ |
| 4 | ∞ | ∞ | ∞ | 0 | ∞ |
| 5 | ∞ | ∞ | ∞ | ∞ | 0 |


### 📌 간선 정보 반영 후

| S/E | 1 | 2 | 3 | 4 | 5 |
|------|---|---|---|---|---|
| 1 | 0 | 8 | 3 | ∞ | ∞ |
| 2 | ∞ | 0 | ∞ | -4 | 15 |
| 3 | ∞ | ∞ | 0 | 13 | ∞ |
| 4 | ∞ | ∞ | ∞ | 0 | 2 |
| 5 | ∞ | ∞ | ∞ | 5 | 0 |


### 📌 간선 정보 반영 후

| S/E | 1 | 2 | 3 | 4 | 5 |
|------|---|---|---|---|---|
| 1 | 0 | 8 | 3 | 4 | 6 |
| 2 | ∞ | 0 | ∞ | -4 | 15 |
| 3 | ∞ | ∞ | 0 | 13 | -2 |
| 4 | ∞ | ∞ | ∞ | 0 | 2 |
| 5 | ∞ | ∞ | ∞ | 5 | 0 |



---

## 🔁 회고
- 플로이드-워셜은 모든 정점 쌍 간 최단 거리를 구하는 데 특화된 알고리즘
- 시간 복잡도가 O(V³)로 크기 때문에 V가 100~200 이하인 경우에만 실용적
- 다익스트라나 벨만-포드는 “단일 시작점 → 다른 모든 노드”가 목적이라면, 플로이드-워셜은 전체 쌍 간 거리가 목적일 때 적합
- 음수 사이클은 탐지하지 못하므로 별도 체크가 필요

---

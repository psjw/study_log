---
tags:
  - review
  - "#webflux"
  - "#flashcards"
review-due: 2025-07-26
review-last-reviewed: 2025-07-26
---
## 📘 WebFlux 리액티브 프로그래밍 - Flashcards
- [[#2025-07-21 - 리액티브 프로그래밍이란?|2025-07-21 - 리액티브 프로그래밍이란?]]
- [[#2025-07-21 - 스레드란?|2025-07-21 - 스레드란?]]
- [[#2025-07-21 - 블로킹과 비동기프로그래밍이란?|2025-07-21 - 블로킹과 비동기프로그래밍이란?]]
- [[#2025-07-23 - Reactive Stream - 함수형 프로그래밍이란?|2025-07-23 - Reactive Stream - 함수형 프로그래밍이란?]]
- [[#2025-07-23 - WebFlux의 Subscriber - Publisher 패턴|2025-07-23 - WebFlux의 Subscriber - Publisher 패턴]]
- [[#2025-07-23 - Netty와 이벤트 루프 패턴|2025-07-23 - Netty와 이벤트 루프 패턴]]
- [[#2025-07-23 - WebFlux는 Netty와 어떻게 통합될까?|2025-07-23 - WebFlux는 Netty와 어떻게 통합될까?]]

### 2025-07-21 - 리액티브 프로그래밍이란?
--- 

**Q:** Spring WebFlux란 무엇인가요?
?
**A:** 비동기 논블로킹 I/O 기반의 Spring 웹 프레임워크로, Netty 등을 사용해 높은 확장성과 자원 효율성을 제공함.
<!--SR:!2025-07-30,3,256-->

---

**Q:** 리액티브 서비스는 어떤 상황에서 유리한가요?
?
**A:** 요청이 많고 리소스가 한정된 상황에서 자원을 효율적으로 쓰며, 높은 응답성과 확장성을 제공합니다.
<!--SR:!2025-07-30,3,252-->

---

**Q:** Tomcat 기반 동기 방식의 I/O 처리 흐름은?
?
**A:** 요청이 들어오면 I/O가 완료될 때까지 해당 스레드는 대기하며 다른 작업을 수행하지 못합니다.
<!--SR:!2025-07-30,3,252-->

---

**Q:** Netty 기반 비동기/논블로킹 방식의 흐름은?
?
**A:** 요청을 OS에 위임하고 콜백을 등록하여 이벤트 루프가 처리하며, 스레드는 즉시 다음 작업을 수행할 수 있습니다.
<!--SR:!2025-07-29,1,216-->

---

**Q:** 전통적인 동기/블로킹 방식과 비동기/논블로킹 방식의 차이를 치킨 배달에 비유하면?
?
**A:** 
- 동기: 문 앞에서 치킨을 기다림 (스레드 대기)
- 비동기: 어머니가 메모를 남기고 나는 다른 일 (OS에 이벤트 등록)
<!--SR:!2025-07-31,4,272-->

---

**Q:** `text/event-stream`의 의미는 무엇인가요?
?
**A:** 클라이언트가 서버로부터 실시간 스트리밍 데이터를 받기 위한 헤더 형식(Server-Sent Events, SSE).
<!--SR:!2025-07-31,3,256-->

---

**Q:** Thread.sleep()을 사용하는 동기식 코드의 문제점은?
?
**A:** 스레드를 블로킹하므로, 리액티브 방식에서 부적합합니다.
<!--SR:!2025-07-31,4,272-->

---

**Q:** WebFlux가 사용하는 주요 리액티브 타입 두 가지는?
?
**A:** Flux(N개의 데이터)와 Mono(1개의 데이터)
<!--SR:!2025-07-31,4,272-->

---

**Q:** Flux와 Mono의 차이는?
?
**A:** Flux는 0~N개의 데이터 스트림을, Mono는 최대 1개의 데이터 스트림을 비동기적으로 처리합니다.
<!--SR:!2025-07-31,4,272-->

---

**Q:** Netty가 WebFlux에서 중요한 이유는?
?
**A:** 이벤트 루프 기반의 논블로킹 네트워크 처리 구조를 제공하기 때문.
<!--SR:!2025-07-31,3,252-->

---

**Q:** WebFlux에서 JDBC 대신 사용하는 비동기 DB 접근 기술은?
?
**A:** R2DBC
<!--SR:!2025-07-31,4,272-->

---

**Q:** WebFlux에서 Thread.sleep()을 지양해야 하는 이유는?
?
**A:** 블로킹 호출이기 때문. 리액티브 환경에서는 Flux.interval() 등의 논블로킹 API를 사용해야 함.
<!--SR:!2025-07-30,3,268-->

---

**Q:** 리액티브 서비스의 장점은?
?
**A:** 자원 효율성, 높은 동시성 처리, 빠른 응답성, 사용자 경험 향상
<!--SR:!2025-07-30,3,252-->

---

**Q:** 함수형 스타일에서 흔히 사용되는 연산자 3가지는?
?
**A:** map, flatMap, filter
<!--SR:!2025-07-31,4,276-->

---

**Q:** 리액티브 프로그래밍의 3대 핵심 포인트는?
?
**A:** 
- 리액티브 스트림
- 완전한 논블로킹 흐름
- 함수형 체이닝 스타일
<!--SR:!2025-07-30,3,252-->

---

**Q:** WebFlux에서 실시간 스트리밍을 위해 클라이언트 요청 헤더에는 Accept: ==text/event-stream==을 설정해야한다.
<!--SR:!2025-07-30,3,256-->

--- 

**Q:** 리액티브 프로그래밍에서는 순차 처리를 위해 ==함수형 스타일== 기반의 연산 체이닝을 사용하며, side-effect를 최소화한다.
<!--SR:!2025-07-31,4,276-->

--- 

**Q:** 리액티브 환경에서는 Thread.sleep() 대신 ==Mono.delay()== 또는 Flux.interval()을 활용한다.
<!--SR:!2025-07-31,4,276-->

--- 

**Q:** 다음 기술 또는 개념을 블로킹 / 논블로킹으로 분류하세요.
- A. JDBC
- B. Netty
- C. Thread.sleep()
- D. Flux.interval()
- E. WebClient
?
**A:**
- 블로킹: A, C
- 논블로킹: B, D, E
<!--SR:!2025-07-31,4,276-->

--- 

**Q:** 아래 Java 코드에서 리액티브하지 않은 부분은 어디이며, 왜 문제가 되는가?
```java
Flux.create(sink -> {
    for (int i = 1; i < 10; i++) {
        Thread.sleep(500);
        sink.next(i);
    }
    sink.complete();
});
```
?
**A:** Thread.sleep(500)은 블로킹 코드로, 리액티브 환경에서는 Mono.delay() 또는 Flux.interval()로 대체해야 한다.
<!--SR:!2025-07-31,4,276-->

--- 


### 2025-07-21 - 스레드란?
--- 

**Q:** Tomcat과 Netty의 스레드 수 차이는?
?
**A:** Tomcat은 수백 개 이상의 스레드를 사용하지만, Netty는 CPU 코어 수와 유사한 소수의 스레드만 사용한다.
<!--SR:!2025-07-31,4,275-->

--- 

**Q:** Tomcat의 블로킹 구조가 가지는 단점은?
?
**A:** I/O나 대기 시간이 발생해도 스레드가 점유되어 비효율적이며, 많은 요청이 몰릴 경우 스레드 부족이 발생한다.
<!--SR:!2025-07-30,3,255-->

--- 

**Q:** Netty의 이벤트 루프는 어떤 방식으로 네트워크 I/O를 처리하는가?
?
**A:** 네트워크 I/O 작업은 OS에 위임하고, 이벤트 완료 알림을 받아 처리한다.
<!--SR:!2025-07-30,2,235-->

--- 

**Q:** Tomcat과 Netty의 가장 큰 구조적 차이는 무엇인가?
?
**A:** Tomcat은 요청당 스레드 생성, Netty는 이벤트 루프 기반의 소수 스레드로 다수 요청 처리.
<!--SR:!2025-07-31,4,275-->

--- 

**Q:** Tomcat에서 하나의 요청은 어떤 방식으로 처리되는가?
?
**A:** 요청당 하나의 스레드가 생성되어 요청 수락 → 요청 읽기 → 코드 실행 → 응답 쓰기를 순차적으로 처리한다.
<!--SR:!2025-07-30,3,257-->

--- 

**Q:** Netty에서 스레드를 과도하게 생성하면 안 되는 이유는?
?
**A:** 컨텍스트 스위칭 비용이 증가하여 CPU 효율이 떨어지기 때문.
<!--SR:!2025-07-30,3,255-->

--- 

**Q:** Tomcat의 스레드 처리 방식은 어떤 I/O 기반인가?
?
**A:** 블로킹 I/O 기반
<!--SR:!2025-07-31,4,275-->

--- 

**Q:** Netty가 많은 요청을 적은 스레드로 처리할 수 있는 이유는?
?
**A:** 비동기 이벤트 기반 처리 구조와 OS Selector를 활용하기 때문.
<!--SR:!2025-07-29,1,217-->

--- 

**Q:** Netty에서 Selector는 어떤 역할을 하는가?
?
**A:** 네트워크 이벤트를 감지하고 알림을 통해 비동기 처리 흐름을 트리거한다
<!--SR:!2025-07-29,1,215-->

--- 

**Q:** 스레드는 물리적으로 어떻게 실행되는가?
?
**A:** OS가 논리 스레드를 시분할로 물리 CPU에 스케줄링하여 실행한다.
<!--SR:!2025-07-30,3,255-->

--- 

**Q:** Netty는 일반적으로 스레드를 몇 개 정도 유지하는가?
?
**A:** CPU 코어 수와 동일하거나 유사한 수준
<!--SR:!2025-07-31,4,275-->

--- 

**Q:** Netty에서 블로킹 코드를 사용하면 발생할 수 있는 문제는?
?
**A:** 이벤트 루프가 지연되어 전체 성능이 심각하게 저하된다.
<!--SR:!2025-07-30,3,257-->

--- 
### 2025-07-21 - 블로킹과 비동기프로그래밍이란?

--- 

**Q:** 비동기 프로그래밍이란 무엇인가요?
?
**A:** 대기 시간이 필요한 작업을 다른 곳에 위임하고, 주 흐름은 멈추지 않고 계속 실행되는 프로그래밍 방식.
<!--SR:!2025-08-01,4,283-->

--- 

**Q:** 블로킹(Blocking)이란 무엇인가요?
?
**A:** 스레드가 외부 작업 결과를 기다리며 멈춰 있는 상태로, 해당 스레드는 아무 일도 하지 못한다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 논블로킹(Non-Blocking)이란 무엇인가요?
?
**A:** 스레드가 기다리지 않고 다른 작업을 이어서 처리하며, 이벤트나 콜백으로 후속 작업을 이어가는 방식.
<!--SR:!2025-07-30,2,238-->

--- 

**Q:** 블로킹 작업의 대표적인 예시는 무엇인가요?
?
**A:** DB 조회, 파일 I/O, HTTP 통신, 네트워크 응답 대기 등 대부분의 외부 I/O
<!--SR:!2025-08-01,4,287-->
<!--SR:!2025-08-01,4,287-->

--- 

**Q:** 비동기 프로그래밍에서 “중요한 스레드”는 어떤 전략으로 동작해야 하나요?
?
**A:** 블로킹 없이 빠르게 반환하고, 실제 작업은 백그라운드 스레드에 위임해야 한다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** Java에서 비동기 처리를 위한 대표적 API는?
?
**A:** CompletableFuture
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** WebFlux에서 비동기 처리는 어떤 방식으로 이루어지나요?
?
**A:** Reactor의 Scheduler 워커 스레드가 Flux/Mono 흐름에 따라 논블로킹으로 작업을 실행함.
<!--SR:!2025-08-01,4,283-->

--- 

**Q:** 블로킹 작업의 대표적인 예시는 무엇인가요?
?
**A:** DB 조회, 파일 I/O, HTTP 통신, 네트워크 응답 대기 등 대부분의 외부 I/O

--- 

**Q:** Netty의 비동기 처리 방식은 어떤 특징이 있나요?
?
**A:** OS의 Selector를 활용하여 이벤트 기반으로 I/O를 감지하고 처리한다.
<!--SR:!2025-07-31,3,263-->

--- 

Q: 비동기 처리 시 후속 로직 실행은 언제 이루어지나요?
?
A: 위임된 블로킹 작업이 완료된 후, 콜백 또는 이벤트 핸들러를 통해 실행된다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 다음 작업을 블로킹 / 논블로킹으로 분류하세요
- A. DB 조회 (JDBC)
- B. 파일 쓰기
- C. 계산 로직
- D. WebClient 요청
- E. Thread.sleep()
- F. Mono.delay()
?
**A:**
- 블로킹: A, B, E
- 논블로킹: C, D, F
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 대부분의 I/O 작업은 ==블로킹==기반이다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** CPU 연산은 일반적으로 ==논블로킹==기반이다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** Java에서 비동기 처리를 위해 사용하는 대표적인 클래스는 ==CompletableFuture== 이다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 비동기 프로그래밍에서는 작업을 OS나 ==백그라운드 스레드==에 위임하고, 주요 스레드는 즉시 반환한다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 비동기 처리가 일어나는 순서를 나열하세요.
1. 주요 스레드가 요청 수신
2. 블로킹 작업을 백그라운드로 위임
3. 주요 스레드는 즉시 반환 or 대기
4. 백그라운드 스레드가 작업 완료
5. 후속 로직이 실행되어 사용자에 응답
?
**A:**
→ 1 → 2 → 3 → 4 → 5
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 다음 Java 코드는 어떤 방식인가요?
```java
List<Integer> result = new ArrayList<>();
for (int i = 0; i < 10; i++) {
    Thread.sleep(500);  // 0.5초 대기
    result.add(i);
}
```
?
**A:** 블로킹 방식입니다. Thread.sleep()은 호출된 스레드를 멈추게 하므로, 처리 중에는 다른 작업이 불가능합니다.
<!--SR:!2025-07-31,4,278-->

---

**Q:** 아래 코드는 어떤 비동기 처리 모델을 따르고 있나요?
```java
Flux.interval(Duration.ofSeconds(1))
    .take(10)
    .subscribe(System.out::println);
```
?
**A:** 논블로킹 비동기 처리입니다. Flux.interval()은 리액터 스케줄러에 의해 백그라운드에서 실행되며, 스레드를 블로킹하지 않습니다.
<!--SR:!2025-07-30,3,258-->

--- 

### 2025-07-23 - Reactive Stream - 함수형 프로그래밍이란?

--- 

### 2025-07-23 - WebFlux의 Subscriber - Publisher 패턴

--- 

###  2025-07-23 - Netty와 이벤트 루프 패턴

--- 

###  2025-07-23 - WebFlux는 Netty와 어떻게 통합될까?

--- 

### 2025-07-28 - WebFlux의 기본적인 사용법, Flux와 Mono

--- 

**Q:** Flux란 무엇인가요?
?
**A:** 0개 이상의 데이터를 비동기적으로 발행하는 리액티브 스트림. 예: List, Stream
<!--SR:!2025-07-31,3,267-->

---

**Q:** Mono는 어떤 경우에 사용하는 것이 적절한가요?
?
**A:** 최대 1개의 데이터를 처리할 때. 단일 데이터 처리 시 더 명확하고 직관적이다.
<!--SR:!2025-07-31,3,264-->

---

**Q:** `Mono<Void>`는 언제 사용하나요?
?
**A:** 반환할 데이터가 없을 때. 즉, "작업은 완료되었지만 결과는 없음"을 나타냄.
<!--SR:!2025-08-01,4,284-->

---

**Q:** subscribe()가 호출되지 않으면 어떤 일이 일어나나요?
?
**A:** 아무 연산도 실행되지 않는다. Flux/Mono는 lazy(지연 실행) 구조이다.
<!--SR:!2025-07-31,3,264-->

---

**Q:** block() 메서드의 기능은 무엇인가요?
?
**A:** Mono의 결과가 나올 때까지 현재 스레드를 블로킹(대기)시킨다.
<!--SR:!2025-08-01,4,284-->

---

**Q:** WebFlux에서 block() 사용이 문제가 되는 이유는?
?
**A:** Netty 기반 이벤트 루프를 멈추기 때문에 전체 시스템의 처리 흐름이 지연됨.
<!--SR:!2025-08-01,4,284-->

---

**Q:** WebFlux에서 동기 값을 반환하면 내부적으로 어떤 처리가 일어나나요?
?
**A:** 내부적으로 Mono.just(...)로 감싸서 리액티브 흐름에 맞게 처리함.
<!--SR:!2025-07-31,3,264-->

---

**Q:** Flux.map()과 filter()는 어떤 역할을 하나요?
?
**A:** map()은 데이터 변환, filter()는 조건에 따라 데이터 필터링.
<!--SR:!2025-08-01,4,287-->

---

**Q:** Mono.just(...)는 어떤 용도로 사용되나요?
?
**A:** 하나의 값을 비동기적으로 감싸서 리액티브 처리할 수 있게 만듦.
<!--SR:!2025-07-29,1,247-->

---

**Q:** Flux와 Mono의 핵심 차이점은 무엇인가요?
?
**A:** Flux는 0~N개의 데이터 발행, Mono는 0~1개의 데이터 발행.
<!--SR:!2025-08-01,4,284-->

--- 

**Q:** Flux는 ==0==개 이상의 데이터를 발행한다.
<!--SR:!2025-08-01,4,284-->

---

**Q:** Mono는 최대 ==1==개의 데이터만 발행한다.
<!--SR:!2025-08-01,4,284-->

--- 

**Q:** WebFlux는 일반 객체를 반환하면 내부적으로 Mono.==just(...)==로 자동 포장한다.
<!--SR:!2025-08-01,4,287-->

---

**Q:** block()은 Mono의 데이터를 동기적으로 추출할 수 있지만, 이벤트 루프를 ==블로킹==시킬 수 있다.
<!--SR:!2025-07-29,1,244-->

--- 

**Q:** Flux나 Mono의 기본 동작 순서를 올바르게 정렬하세요.
1. subscribe() 호출
2. just() 또는 fromXXX()로 생성
3. map(), filter() 등의 연산자 적용
?
**A:**
→ 2 → 3 → 1
<!--SR:!2025-08-01,4,284-->

--- 

**Q:** 다음 Mono 코드의 출력 결과는?
```java
Mono.just(2)
    .map(i -> i * 2)
    .filter(i -> i % 4 == 0)
    .subscribe(System.out::println);
```
?
**A:** 4가 출력된다. (2 → 4 → 필터 통과)
<!--SR:!2025-08-01,4,284-->

--- 

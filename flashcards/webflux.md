---
tags:
  - review
  - "#webflux"
  - "#flashcards"
review-due: 2025-07-26
review-last-reviewed: 2025-07-26
---
## 📘 WebFlux 리액티브 프로그래밍 - Flashcards
--- 

- [[#2025-07-21 - 리액티브 프로그래밍이란?|2025-07-21 - 리액티브 프로그래밍이란?]]
- [[#2025-07-21 - 스레드란?|2025-07-21 - 스레드란?]]
- [[#2025-07-21 - 블로킹과 비동기프로그래밍이란?|2025-07-21 - 블로킹과 비동기프로그래밍이란?]]
- [[#2025-07-23 - Reactive Stream - 함수형 프로그래밍이란?|2025-07-23 - Reactive Stream - 함수형 프로그래밍이란?]]
- [[#2025-07-23 - WebFlux의 Subscriber - Publisher 패턴|2025-07-23 - WebFlux의 Subscriber - Publisher 패턴]]
- [[#2025-07-23 - Netty와 이벤트 루프 패턴|2025-07-23 - Netty와 이벤트 루프 패턴]]
- [[#2025-07-23 - WebFlux는 Netty와 어떻게 통합될까?|2025-07-23 - WebFlux는 Netty와 어떻게 통합될까?]]
- [[#2025-07-28 - WebFlux의 기본적인 사용법, Flux와 Mono|2025-07-28 - WebFlux의 기본적인 사용법, Flux와 Mono]]
- [[#2025-07-29 - Operator의 활용 - Mono|2025-07-29 - Operator의 활용 - Mono]]

--- 

### 2025-07-21 - 리액티브 프로그래밍이란?
--- 

**Q:** Spring WebFlux란 무엇인가요?
?
**A:** 비동기 논블로킹 I/O 기반의 Spring 웹 프레임워크로, Netty 등을 사용해 높은 확장성과 자원 효율성을 제공함.
<!--SR:!2025-08-07,8,256-->

---

**Q:** 리액티브 서비스는 어떤 상황에서 유리한가요?
?
**A:** 요청이 많고 리소스가 한정된 상황에서 자원을 효율적으로 쓰며, 높은 응답성과 확장성을 제공합니다.
<!--SR:!2025-08-07,8,252-->

---

**Q:** Tomcat 기반 동기 방식의 I/O 처리 흐름은?
?
**A:** 요청이 들어오면 I/O가 완료될 때까지 해당 스레드는 대기하며 다른 작업을 수행하지 못합니다.
<!--SR:!2025-08-01,2,232-->

---

**Q:** Netty 기반 비동기/논블로킹 방식의 흐름은?
?
**A:** 요청을 OS에 위임하고 콜백을 등록하여 이벤트 루프가 처리하며, 스레드는 즉시 다음 작업을 수행할 수 있습니다.
<!--SR:!2025-07-31,1,196-->

---

**Q:** 전통적인 동기/블로킹 방식과 비동기/논블로킹 방식의 차이를 치킨 배달에 비유하면?
?
**A:** 
- 동기: 문 앞에서 치킨을 기다림 (스레드 대기)
- 비동기: 어머니가 메모를 남기고 나는 다른 일 (OS에 이벤트 등록)
<!--SR:!2025-07-31,4,272-->

---

**Q:** `text/event-stream`의 의미는 무엇인가요?
?
**A:** 클라이언트가 서버로부터 실시간 스트리밍 데이터를 받기 위한 헤더 형식(Server-Sent Events, SSE).
<!--SR:!2025-07-31,3,256-->

---

**Q:** Thread.sleep()을 사용하는 동기식 코드의 문제점은?
?
**A:** 스레드를 블로킹하므로, 리액티브 방식에서 부적합합니다.
<!--SR:!2025-07-31,4,272-->

---

**Q:** WebFlux가 사용하는 주요 리액티브 타입 두 가지는?
?
**A:** Flux(N개의 데이터)와 Mono(1개의 데이터)
<!--SR:!2025-07-31,4,272-->

---

**Q:** Flux와 Mono의 차이는?
?
**A:** Flux는 0~N개의 데이터 스트림을, Mono는 최대 1개의 데이터 스트림을 비동기적으로 처리합니다.
<!--SR:!2025-07-31,4,272-->

---

**Q:** Netty가 WebFlux에서 중요한 이유는?
?
**A:** 이벤트 루프 기반의 논블로킹 네트워크 처리 구조를 제공하기 때문.
<!--SR:!2025-07-31,3,252-->

---

**Q:** WebFlux에서 JDBC 대신 사용하는 비동기 DB 접근 기술은?
?
**A:** R2DBC
<!--SR:!2025-07-31,4,272-->

---

**Q:** WebFlux에서 Thread.sleep()을 지양해야 하는 이유는?
?
**A:** 블로킹 호출이기 때문. 리액티브 환경에서는 Flux.interval() 등의 논블로킹 API를 사용해야 함.
<!--SR:!2025-08-01,2,248-->

---

**Q:** 리액티브 서비스의 장점은?
?
**A:** 자원 효율성, 높은 동시성 처리, 빠른 응답성, 사용자 경험 향상
<!--SR:!2025-08-06,7,252-->

---

**Q:** 함수형 스타일에서 흔히 사용되는 연산자 3가지는?
?
**A:** map, flatMap, filter
<!--SR:!2025-07-31,4,276-->

---

**Q:** 리액티브 프로그래밍의 3대 핵심 포인트는?
?
**A:**
- 리액티브 스트림
- 완전한 논블로킹 흐름
- 함수형 체이닝 스타일
<!--SR:!2025-08-07,8,252-->

---

**Q:** WebFlux에서 실시간 스트리밍을 위해 클라이언트 요청 헤더에는 Accept: ==text/event-stream==을 설정해야한다.
<!--SR:!2025-08-01,2,236-->

--- 

**Q:** 리액티브 프로그래밍에서는 순차 처리를 위해 ==함수형 스타일== 기반의 연산 체이닝을 사용하며, side-effect를 최소화한다.
<!--SR:!2025-07-31,4,276-->

--- 

**Q:** 리액티브 환경에서는 Thread.sleep() 대신 ==Mono.delay()== 또는 Flux.interval()을 활용한다.
<!--SR:!2025-07-31,4,276-->

--- 

**Q:** 다음 기술 또는 개념을 블로킹 / 논블로킹으로 분류하세요.
- A. JDBC
- B. Netty
- C. Thread.sleep()
- D. Flux.interval()
- E. WebClient
?
**A:**
- 블로킹: A, C
- 논블로킹: B, D, E
<!--SR:!2025-07-31,4,276-->

--- 

**Q:** 아래 Java 코드에서 리액티브하지 않은 부분은 어디이며, 왜 문제가 되는가?
```java
Flux.create(sink -> {
    for (int i = 1; i < 10; i++) {
        Thread.sleep(500);
        sink.next(i);
    }
    sink.complete();
});
```
?
**A:** Thread.sleep(500)은 블로킹 코드로, 리액티브 환경에서는 Mono.delay() 또는 Flux.interval()로 대체해야 한다.
<!--SR:!2025-07-31,4,276-->

--- 

### 2025-07-21 - 스레드란?

--- 

**Q:** Tomcat과 Netty의 스레드 수 차이는?
?
**A:** Tomcat은 수백 개 이상의 스레드를 사용하지만, Netty는 CPU 코어 수와 유사한 소수의 스레드만 사용한다.
<!--SR:!2025-07-31,4,275-->

--- 

**Q:** Tomcat의 블로킹 구조가 가지는 단점은?
?
**A:** I/O나 대기 시간이 발생해도 스레드가 점유되어 비효율적이며, 많은 요청이 몰릴 경우 스레드 부족이 발생한다.
<!--SR:!2025-08-01,2,235-->

--- 

**Q:** Netty의 이벤트 루프는 어떤 방식으로 네트워크 I/O를 처리하는가?
?
**A:** 네트워크 I/O 작업은 OS에 위임하고, 이벤트 완료 알림을 받아 처리한다.
<!--SR:!2025-07-31,1,215-->

--- 

**Q:** Tomcat과 Netty의 가장 큰 구조적 차이는 무엇인가?
?
**A:** Tomcat은 요청당 스레드 생성, Netty는 이벤트 루프 기반의 소수 스레드로 다수 요청 처리.
<!--SR:!2025-07-31,4,275-->

--- 

**Q:** Tomcat에서 하나의 요청은 어떤 방식으로 처리되는가?
?
**A:** 요청당 하나의 스레드가 생성되어 요청 수락 → 요청 읽기 → 코드 실행 → 응답 쓰기를 순차적으로 처리한다.
<!--SR:!2025-08-08,9,257-->

--- 

**Q:** Netty에서 스레드를 과도하게 생성하면 안 되는 이유는?
?
**A:** 컨텍스트 스위칭 비용이 증가하여 CPU 효율이 떨어지기 때문.
<!--SR:!2025-08-06,7,255-->

--- 

**Q:** Tomcat의 스레드 처리 방식은 어떤 I/O 기반인가?
?
**A:** 블로킹 I/O 기반
<!--SR:!2025-07-31,4,275-->

--- 

**Q:** Netty가 많은 요청을 적은 스레드로 처리할 수 있는 이유는?
?
**A:** 비동기 이벤트 기반 처리 구조와 OS Selector를 활용하기 때문.
<!--SR:!2025-07-31,1,197-->

--- 

**Q:** Netty에서 Selector는 어떤 역할을 하는가?
?
**A:** 네트워크 이벤트를 감지하고 알림을 통해 비동기 처리 흐름을 트리거한다
<!--SR:!2025-07-31,1,195-->

--- 

**Q:** 스레드는 물리적으로 어떻게 실행되는가?
?
**A:** OS가 논리 스레드를 시분할로 물리 CPU에 스케줄링하여 실행한다.
<!--SR:!2025-08-01,2,235-->

--- 

**Q:** Netty는 일반적으로 스레드를 몇 개 정도 유지하는가?
?
**A:** CPU 코어 수와 동일하거나 유사한 수준
<!--SR:!2025-07-31,4,275-->

--- 

**Q:** Netty에서 블로킹 코드를 사용하면 발생할 수 있는 문제는?
?
**A:** 이벤트 루프가 지연되어 전체 성능이 심각하게 저하된다.
<!--SR:!2025-08-08,9,257-->

--- 
### 2025-07-21 - 블로킹과 비동기프로그래밍이란?

--- 

**Q:** 비동기 프로그래밍이란 무엇인가요?
?
**A:** 대기 시간이 필요한 작업을 다른 곳에 위임하고, 주 흐름은 멈추지 않고 계속 실행되는 프로그래밍 방식.
<!--SR:!2025-08-01,4,283-->

--- 

**Q:** 블로킹(Blocking)이란 무엇인가요?
?
**A:** 스레드가 외부 작업 결과를 기다리며 멈춰 있는 상태로, 해당 스레드는 아무 일도 하지 못한다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 논블로킹(Non-Blocking)이란 무엇인가요?
?
**A:** 스레드가 기다리지 않고 다른 작업을 이어서 처리하며, 이벤트나 콜백으로 후속 작업을 이어가는 방식.
<!--SR:!2025-07-31,1,218-->

--- 

**Q:** 비동기 프로그래밍에서 “중요한 스레드”는 어떤 전략으로 동작해야 하나요?
?
**A:** 블로킹 없이 빠르게 반환하고, 실제 작업은 백그라운드 스레드에 위임해야 한다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 블로킹 작업의 대표적인 예시는 무엇인가요?
?
**A:** DB 조회, 파일 I/O, HTTP 통신, 네트워크 응답 대기 등 대부분의 외부 I/O
<!--SR:!2025-08-01,4,290-->

--- 

**Q:** Java에서 비동기 처리를 위한 대표적 API는?
?
**A:** CompletableFuture
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** WebFlux에서 비동기 처리는 어떤 방식으로 이루어지나요?
?
**A:** Reactor의 Scheduler 워커 스레드가 Flux/Mono 흐름에 따라 논블로킹으로 작업을 실행함.
<!--SR:!2025-08-01,4,283-->

--- 

**Q:** Netty의 비동기 처리 방식은 어떤 특징이 있나요?
?
**A:** OS의 Selector를 활용하여 이벤트 기반으로 I/O를 감지하고 처리한다.
<!--SR:!2025-07-31,3,263-->

--- 

Q: 비동기 처리 시 후속 로직 실행은 언제 이루어지나요?
?
A: 위임된 블로킹 작업이 완료된 후, 콜백 또는 이벤트 핸들러를 통해 실행된다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 다음 작업을 블로킹 / 논블로킹으로 분류하세요
- A. DB 조회 (JDBC)
- B. 파일 쓰기
- C. 계산 로직
- D. WebClient 요청
- E. Thread.sleep()
- F. Mono.delay()
?
**A:**
- 블로킹: A, B, E
- 논블로킹: C, D, F
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 대부분의 I/O 작업은 ==블로킹==기반이다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** CPU 연산은 일반적으로 ==논블로킹==기반이다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** Java에서 비동기 처리를 위해 사용하는 대표적인 클래스는 ==CompletableFuture== 이다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 비동기 프로그래밍에서는 작업을 OS나 ==백그라운드 스레드==에 위임하고, 주요 스레드는 즉시 반환한다.
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 비동기 처리가 일어나는 순서를 나열하세요.
1. 주요 스레드가 요청 수신
2. 블로킹 작업을 백그라운드로 위임
3. 주요 스레드는 즉시 반환 or 대기
4. 백그라운드 스레드가 작업 완료
5. 후속 로직이 실행되어 사용자에 응답
?
**A:**
→ 1 → 2 → 3 → 4 → 5
<!--SR:!2025-07-31,4,278-->

--- 

**Q:** 다음 Java 코드는 어떤 방식인가요?
```java
List<Integer> result = new ArrayList<>();
for (int i = 0; i < 10; i++) {
    Thread.sleep(500);  // 0.5초 대기
    result.add(i);
}
```
?
**A:** 블로킹 방식입니다. Thread.sleep()은 호출된 스레드를 멈추게 하므로, 처리 중에는 다른 작업이 불가능합니다.
<!--SR:!2025-07-31,4,278-->

---

**Q:** 아래 코드는 어떤 비동기 처리 모델을 따르고 있나요?
```java
Flux.interval(Duration.ofSeconds(1))
    .take(10)
    .subscribe(System.out::println);
```
?
**A:** 논블로킹 비동기 처리입니다. Flux.interval()은 리액터 스케줄러에 의해 백그라운드에서 실행되며, 스레드를 블로킹하지 않습니다.
<!--SR:!2025-08-06,7,258-->

--- 

### 2025-07-23 - Reactive Stream - 함수형 프로그래밍이란?

--- 

**Q:** **함수형 프로그래밍이란 무엇인가요?**
?
**A:** 상태 변경 없이 함수를 조합하여 선언적으로 코드를 구성하는 프로그래밍 방식입니다.
<!--SR:!2025-07-31,3,270-->

--- 

**Q:** **Java 8 이상에서 함수를 값처럼 다룰 수 있는 인터페이스 3가지는?**
?
**A:** Function, Consumer, Predicate
<!--SR:!2025-08-01,4,287-->

---

**Q:** **리액티브 스트림이 실제 실행되기 위해 반드시 필요한 메서드는?**
?
**A:** subscribe()
<!--SR:!2025-08-01,4,290-->

---

**Q:** **WebFlux Controller에서 subscribe()를 직접 호출하지 않아도 되는 이유는?**
?
**A:** 내부적으로 Netty 이벤트 루프가 자동으로 subscribe를 호출하기 때문입니다.
<!--SR:!2025-07-31,3,270-->

---

**Q:** **Flux와 Mono의 차이는 무엇인가요?**
?
**A:** Flux는 0개 이상의 데이터, Mono는 최대 1개의 데이터를 처리합니다.
<!--SR:!2025-08-01,4,287-->

---

**Q:** **함수형 map 연산자는 어떤 역할을 하나요?**
?
**A:** 각 요소를 다른 값으로 변환합니다.
<!--SR:!2025-08-01,4,287-->

---

**Q:** **리스트의 값을 필터링할 때 사용하는 함수형 인터페이스는?**
?
**A:** `Predicate<T>`
<!--SR:!2025-08-01,4,287-->

---

**Q:** **subscribe()가 호출되기 전까지 아무 일도 일어나지 않는 성질을 무엇이라고 하나요?**
?
**A:** Lazy Evaluation (지연 실행)
<!--SR:!2025-07-31,3,267-->

---

**Q:** **리스트를 함수형으로 출력할 때 사용하는 인터페이스는?**
?
**A:** `Consumer<T>`
<!--SR:!2025-07-31,3,267-->

---

**Q:** **WebFlux 테스트 코드에서 subscribe()를 명시적으로 호출해야 하는 이유는?**
?
**A:** 테스트에서는 Netty 이벤트 루프가 존재하지 않기 때문에 자동 구독이 수행되지 않음
<!--SR:!2025-07-31,3,270-->

--- 

**Q:** Java 8 이상에서는 함수형 인터페이스인 ==Function==, Consumer, Predicate 등을 통해 함수를 객체처럼 다룰 수 있다.
<!--SR:!2025-08-01,4,287-->

--- 

**Q:** 리액티브 스트림은 ==subscribe==() 메서드가 호출되어야 실행된다.
<!--SR:!2025-08-01,4,287-->

---

**Q:** map, filter, flatMap 같은 연산자를 체이닝하는 방식은 ==함수형==프로그래밍의 대표적인 특징이다.
<!--SR:!2025-08-01,4,287-->

--- 

**Q:** 아래 항목을 Flux와 Mono로 구분하세요.
- 최대 1개 데이터
- 0개 이상 여러 개 데이터
- 리스트 기반 스트림
- Optional 느낌
- 다중 스트림 처리
?
**A:**
- Mono: 최대 1개 데이터, Optional 느낌
- Flux: 0개 이상 여러 개 데이터, 리스트 기반 스트림, 다중 스트림 처리
<!--SR:!2025-08-01,4,287-->

--- 

**Q:** 리액티브 스트림의 실행 흐름을 순서대로 나열하세요.
1. 구독 (subscribe)
2. 데이터 발행 (map, filter)
3. 데이터 흐름 생성 (just, range, fromIterable)
?
**A:**
3 → 2 → 1
<!--SR:!2025-08-01,4,287-->

--- 

**Q:** 아래 명령형 코드를 함수형 방식으로 바꿔보세요.
```java
List<Integer> list = new ArrayList<>();
for (int i = 1; i <= 5; i++) {
    list.add(i);
}
```
?
**A:**
```java
List<Integer> list = IntStream.rangeClosed(1, 5)
                              .boxed()
                              .collect(Collectors.toList());
```
<!--SR:!2025-07-31,3,267-->

--- 

**Q:** 아래 함수형 코드에서 동작을 설명하세요.
```java
Flux.range(1, 5)
    .map(n -> n * 2)
    .filter(n -> n % 4 == 0)
    .subscribe(System.out::println);
```
?
**A:**
1부터 5까지 숫자에 2를 곱하고, 그 중 4의 배수만 출력합니다.
<!--SR:!2025-08-01,4,287-->

--- 

### 2025-07-23 - WebFlux의 Subscriber - Publisher 패턴

--- 

**Q.** subscribe()의 역할은 무엇인가요?
?
**A.** 리액티브 스트림의 실행을 시작하는 트리거로, 호출되어야 Flux/Mono에서 데이터가 생성됩니다.
<!--SR:!2025-08-02,3,267-->

---

**Q.** subscribeOn()과 publishOn()의 차이를 설명해주세요.
?
**A.**
- subscribeOn: Publisher(데이터 생성 측)의 실행 스레드를 지정
- publishOn: Subscriber(데이터 처리 측)의 실행 스레드를 지정
<!--SR:!2025-07-31,1,247-->

---

**Q.** Flux 또는 Mono는 데이터를 즉시 포함하고 있나요?
?
**A.** 아니요. 함수형 정의만 가지고 있고, subscribe()가 되어야 실제 데이터 생성이 시작됩니다.
<!--SR:!2025-08-02,3,267-->

---

**Q.** 블로킹 회피를 위해 스레드를 명시적으로 분리하려면 어떤 방법을 사용해야 하나요?
?
**A.** Schedulers.boundedElastic()과 같은 스케줄러를 subscribeOn() 또는 publishOn()에 적용해야 합니다.
<!--SR:!2025-08-02,3,267-->

---

**Q.** 하나의 스레드에서 flatMap 등 연산자만 사용해서 블로킹을 피할 수 있을까요?
?
**A.** ❌ 아니요. 스레드 분리가 없으면 블로킹 회피는 불가능합니다.
<!--SR:!2025-08-03,4,287-->

---

**Q.** Hot Sequence의 예는 어떤 것이 있을까요?
?
**A.** Flux.publish() 또는 ConnectableFlux, 실시간 센서/소켓 등은 구독 여부와 관계없이 데이터를 발행하는 **Hot Sequence**입니다.
<!--SR:!2025-08-02,3,267-->

---

**Q.** Cold Sequence는 어떤 특성이 있나요?
?
**A.** 구독이 있어야 데이터 발행이 시작되며, 각 구독자는 독립적으로 데이터를 수신합니다.
<!--SR:!2025-08-02,3,267-->

---

**Q.** Schedulers.boundedElastic()은 어떤 상황에서 적합한가요?
?
**A.** 파일, DB, 외부 API 등 **블로킹 I/O 처리**가 필요한 경우 별도의 스레드를 통해 처리해야 할 때 사용합니다.
<!--SR:!2025-08-02,3,267-->

---

**Q.** WebFlux의 내부 subscribe()는 언제 자동으로 호출되나요?
?
**A.** 컨트롤러에서 Flux/Mono를 반환할 경우 WebFlux 내부에서 자동으로 호출되어 실행이 시작됩니다.
<!--SR:!2025-08-02,3,267-->

--- 

**Q.** ==Publisher==는 데이터를 발행하는 주체이다.
<!--SR:!2025-08-02,3,267-->

---

**Q.** ==Subscriber==는 데이터를 소비하는 주체이다.
<!--SR:!2025-08-02,3,267--> 

---

**Q.** Mono나 Flux는 ==subscribe()==를 호출하지 않으면 동작하지 않는다.
<!--SR:!2025-08-02,3,267-->

--- 

**Q.** subscribeOn()은 데이터를 소비하는 Subscriber 측의 스레드를 제어한다.
?
**A.** ❌ (→ Publisher 측)
<!--SR:!2025-08-03,4,287-->

---

**Q.** Cold Sequence는 구독이 없어도 데이터를 지속적으로 발행한다.
?
**A.** ❌
<!--SR:!2025-08-03,4,287-->

---

**Q.** Schedulers.boundedElastic()은 블로킹 작업 처리용 스레드를 지원한다.
?
**A.** ⭕
<!--SR:!2025-08-02,3,267-->

---

**Q. WebFlux의 요청 처리 순서를 정렬하세요**
(1) Netty 이벤트 루프가 요청 수신
(2) Controller가 Flux/Mono 반환
(3) WebFlux 내부에서 subscribe() 호출
(4) Netty 이벤트 루프가 비동기 응답 전송
?
**A.** 1 → 2 → 3 → 4
<!--SR:!2025-08-02,3,267-->

--- 

###  2025-07-23 - Netty와 이벤트 루프 패턴

--- 

###  2025-07-23 - WebFlux는 Netty와 어떻게 통합될까?

--- 

### 2025-07-28 - WebFlux의 기본적인 사용법, Flux와 Mono

--- 

**Q:** Flux란 무엇인가요?
?
**A:** 0개 이상의 데이터를 비동기적으로 발행하는 리액티브 스트림. 예: List, Stream
<!--SR:!2025-07-31,3,267-->

---

**Q:** Mono는 어떤 경우에 사용하는 것이 적절한가요?
?
**A:** 최대 1개의 데이터를 처리할 때. 단일 데이터 처리 시 더 명확하고 직관적이다.
<!--SR:!2025-07-31,3,264-->

---

**Q:** `Mono<Void>`는 언제 사용하나요?
?
**A:** 반환할 데이터가 없을 때. 즉, "작업은 완료되었지만 결과는 없음"을 나타냄.
<!--SR:!2025-08-01,4,284-->

---

**Q:** subscribe()가 호출되지 않으면 어떤 일이 일어나나요?
?
**A:** 아무 연산도 실행되지 않는다. Flux/Mono는 lazy(지연 실행) 구조이다.
<!--SR:!2025-07-31,3,264-->

---

**Q:** block() 메서드의 기능은 무엇인가요?
?
**A:** Mono의 결과가 나올 때까지 현재 스레드를 블로킹(대기)시킨다.
<!--SR:!2025-08-01,4,284-->

---

**Q:** WebFlux에서 block() 사용이 문제가 되는 이유는?
?
**A:** Netty 기반 이벤트 루프를 멈추기 때문에 전체 시스템의 처리 흐름이 지연됨.
<!--SR:!2025-08-01,4,284-->

---

**Q:** WebFlux에서 동기 값을 반환하면 내부적으로 어떤 처리가 일어나나요?
?
**A:** 내부적으로 Mono.just(...)로 감싸서 리액티브 흐름에 맞게 처리함.
<!--SR:!2025-07-31,3,264-->

---

**Q:** Flux.map()과 filter()는 어떤 역할을 하나요?
?
**A:** map()은 데이터 변환, filter()는 조건에 따라 데이터 필터링.
<!--SR:!2025-08-01,4,287-->

---

**Q:** Mono.just(...)는 어떤 용도로 사용되나요?
?
**A:** 하나의 값을 비동기적으로 감싸서 리액티브 처리할 수 있게 만듦.
<!--SR:!2025-08-01,2,247-->

---

**Q:** Flux와 Mono의 핵심 차이점은 무엇인가요?
?
**A:** Flux는 0~N개의 데이터 발행, Mono는 0~1개의 데이터 발행.
<!--SR:!2025-08-01,4,284-->

--- 

**Q:** Flux는 ==0==개 이상의 데이터를 발행한다.
<!--SR:!2025-08-01,4,284-->

---

**Q:** Mono는 최대 ==1==개의 데이터만 발행한다.
<!--SR:!2025-08-01,4,284-->

--- 

**Q:** WebFlux는 일반 객체를 반환하면 내부적으로 Mono.==just(...)==로 자동 포장한다.
<!--SR:!2025-08-01,4,287-->

---

**Q:** block()은 Mono의 데이터를 동기적으로 추출할 수 있지만, 이벤트 루프를 ==블로킹==시킬 수 있다.
<!--SR:!2025-08-02,3,264-->

--- 

**Q:** Flux나 Mono의 기본 동작 순서를 올바르게 정렬하세요.
1. subscribe() 호출
2. just() 또는 fromXXX()로 생성
3. map(), filter() 등의 연산자 적용
?
**A:**
→ 2 → 3 → 1
<!--SR:!2025-08-01,4,284-->

--- 

**Q:** 다음 Mono 코드의 출력 결과는?
```java
Mono.just(2)
    .map(i -> i * 2)
    .filter(i -> i % 4 == 0)
    .subscribe(System.out::println);
```
?
**A:** 4가 출력된다. (2 → 4 → 필터 통과)
<!--SR:!2025-08-01,4,284-->

--- 

### 2025-07-29 - Operator의 활용 - Mono

--- 

**Q. Mono.just()는 어떤 역할을 하나요?**
?
**A.** 단일 데이터를 포함한 Mono 인스턴스를 즉시 생성합니다.
<!--SR:!2025-07-31,1,247-->

---

**Q. Mono.empty()는 어떤 특징을 가지나요?**
?
**A.** 데이터 없이 비어 있으며 onNext 이벤트가 발생하지 않는 Mono입니다.
<!--SR:!2025-07-31,1,248-->

---

**Q. 블로킹 코드가 포함된 작업을 안전하게 Mono로 감싸기 위한 연산자(3가지)는 무엇인가요?**
?
**A.** fromCallable() 또는 defer() + subscribeOn(Schedulers.boundedElastic())
<!--SR:!2025-08-02,3,267-->

---

**Q. Mono.defer()는 어떤 상황에서 사용하나요?**
?
**A.** Mono의 생성을 지연시키고, 내부 흐름에서 블로킹 코드를 안전하게 실행하고자 할 때 사용합니다.
<!--SR:!2025-07-31,1,247-->

---

**Q. Mono에서 여러 데이터를 방출하려면 어떤 연산자를 사용하나요?**
?
**A.** flatMapMany()를 사용하여 Flux로 변환합니다.
<!--SR:!2025-08-02,3,268-->

---

**Q. subscribeOn(Schedulers.boundedElastic())의 목적은 무엇인가요?**
?
**A.** 블로킹 작업을 별도의 스레드에서 처리해, 메인 이벤트 루프의 성능 저하를 방지합니다.
<!--SR:!2025-07-31,1,248-->

---

**Q. Mono.fromCallable()과 Mono.defer()의 차이점은 무엇인가요?**

**A.**
- fromCallable()은 즉시 실행 가능한 동기 값을 감쌉니다.
- defer()는 Mono 자체를 반환하며 **실행 시점**까지 연기됩니다.
    
---

**Q. Mono.just()와 Mono.defer()의 주요 차이점은?**
?
**A.**
- just()는 값을 즉시 생성하고 저장합니다.
- defer()는 **구독 시점에 Mono 생성**을 지연시킵니다.
<!--SR:!2025-08-02,3,267-->

---

**Q. Mono를 Flux로 변환하려면 어떤 방식으로 접근해야 하나요?**
?
**A.** flatMapMany()를 사용하여 Mono가 가진 값을 기반으로 Flux로 확장합니다.
<!--SR:!2025-08-02,3,267-->

---

**Q. 리액티브 흐름에서 블로킹 코드를 사용하면 어떤 문제가 발생하나요?**
?
**A.** 이벤트 루프가 막히고 전체 성능이 저하되어 시스템 전체에 병목을 발생시킵니다.
<!--SR:!2025-07-31,1,248-->

--- 

**Q.** Mono.defer()는 Mono 생성 자체를 ==구독(subscribe)== 시점으로 지연시킨다.
<!--SR:!2025-08-02,3,267-->

---

**Q.** Mono.fromCallable()은 ==동기적실행== 결과를 Mono로 감싼다.
<!--SR:!2025-08-02,3,267-->

--- 

**Q.** Mono.just()는 subscribe 전에 값을 계산하지 않는다.
?
**A.** ❌ (계산은 just 생성 시에 즉시 일어남)
<!--SR:!2025-08-03,4,287-->

---

**Q.** Mono.defer()는 subscribe 시점까지 내부 로직의 실행을 미룰 수 있다.
?
**A.** ⭕
<!--SR:!2025-08-02,3,267-->

---

**Q.** flatMapMany()는 Flux를 Mono로 줄이는 연산이다.
?
**A.** ❌ (Mono → Flux 확장)
<!--SR:!2025-07-31,1,248-->

--- 

**Q. 다음 연산자의 리액티브 흐름을 순서대로 나열하세요**
(1) subscribe()
(2) 생성 연산자 (just, empty, defer 등)
(3) 가공 연산자 (map, flatMap 등)
?
**A.**  2 → 3 → 1
<!--SR:!2025-08-02,3,267-->

--- 

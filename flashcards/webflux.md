---
tags:
  - flashcards
  - review
review-due: 2025-07-26
review-last-reviewed: 2025-07-26
---
## 📘 WebFlux 리액티브 프로그래밍 - Flashcards
### 2025-07-21 - 리액티브 프로그래밍이란?
--- 

Spring WebFlux란 무엇인가요?
?
비동기 논블로킹 I/O 기반의 Spring 웹 프레임워크로, Netty 등을 사용해 높은 확장성과 자원 효율성을 제공함.

---

리액티브 서비스는 어떤 상황에서 유리한가요?
?
요청이 많고 리소스가 한정된 상황에서 자원을 효율적으로 쓰며, 높은 응답성과 확장성을 제공합니다.

---

Tomcat 기반 동기 방식의 I/O 처리 흐름은?
?
요청이 들어오면 I/O가 완료될 때까지 해당 스레드는 대기하며 다른 작업을 수행하지 못합니다.

---

Netty 기반 비동기/논블로킹 방식의 흐름은?
?
요청을 OS에 위임하고 콜백을 등록하여 이벤트 루프가 처리하며, 스레드는 즉시 다음 작업을 수행할 수 있습니다.

---

전통적인 동기/블로킹 방식과 비동기/논블로킹 방식의 차이를 치킨 배달에 비유하면?
?
- 동기: 문 앞에서 치킨을 기다림 (스레드 대기)  
- 비동기: 어머니가 메모를 남기고 나는 다른 일 (OS에 이벤트 등록)

---

`text/event-stream`의 의미는 무엇인가요?
?
클라이언트가 서버로부터 실시간 스트리밍 데이터를 받기 위한 헤더 형식(Server-Sent Events, SSE).

---

Thread.sleep()을 사용하는 동기식 코드의 문제점은?
?
스레드를 블로킹하므로, 리액티브 방식에서 부적합합니다.

---

WebFlux가 사용하는 주요 리액티브 타입 두 가지는?
?
Flux(N개의 데이터)와 Mono(1개의 데이터)

---

Flux와 Mono의 차이는?
?
Flux는 0~N개의 데이터 스트림을, Mono는 최대 1개의 데이터 스트림을 비동기적으로 처리합니다.

---

Netty가 WebFlux에서 중요한 이유는?
?
이벤트 루프 기반의 논블로킹 네트워크 처리 구조를 제공하기 때문.

---

WebFlux에서 JDBC 대신 사용하는 비동기 DB 접근 기술은?
?
R2DBC

---

WebFlux에서 Thread.sleep()을 지양해야 하는 이유는?
?
블로킹 호출이기 때문. 리액티브 환경에서는 Flux.interval() 등의 논블로킹 API를 사용해야 함.

---

리액티브 서비스의 장점은?
?
자원 효율성, 높은 동시성 처리, 빠른 응답성, 사용자 경험 향상

---

리액티브 서비스의 장점은?
?
map, flatMap, filter

---

리액티브 프로그래밍의 3대 핵심 포인트는?
?
- 리액티브 스트림
- 완전한 논블로킹 흐름
- 함수형 체이닝 스타일

---

### 2025-07-21 - 스레드란?


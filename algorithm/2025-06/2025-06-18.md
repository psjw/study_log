# 🧠 2025-06-18 알고리즘 풀이

## 📌 문제 1 :[프로그래머스 12909] 올바른 괄호

### ✅ 문제 요약
- 주어진 문자열에서 ()괄호가 되면 제거되며 모든 괄호가 제거 되면 성공
- 주어진 문자열의 괄호가 모두 제거되면 true 아니면 false

### 💡 접근 방식
- 입력 크기: s ≤ 100,000 → O(NlogN) 이하(500,000) 알고리즘으로 해결 가능
- 입력괄호가 `)` 일 경우 stack에 peek() 값이 `(`일 경우 pop 아니면 push 
- 최종적으로 stack이 비어있으면 true 반환 

### 💻 풀이 코드
```java
stack.push(s.charAt(0));

for (int i = 1; i < s.length(); i++) {
    char currentChar = s.charAt(i);
    if (!stack.isEmpty() 
            && stack.peek() == '(' && currentChar == ')') {
        stack.pop();
    } else {
        stack.push(currentChar);
    }
}
```
### 🔁 회고

- stack의 특징을 기억하자
- stack이 최초 비어있을 경우에는 초기값을 먼저 세팅해주자

---




## 📌 문제 2 :[프로그래머스 42587] 프로세스

### ✅ 문제 요약
- 큐에서 우선순위가 높은 프로세스 순으로 실행하되, 우선순위가 낮은 프로세스는 큐에 다시 넣음
- location이 나타내는 프로세스의 순서 구하기
- 입력 크기: 1 ≤ priorities ≤ 100, 1 ≤ priorities의 값 ≤ 9

### 💡 접근 방식
- 입력 크기: 1 ≤ priorities ≤ 100 → O(N^2) (10,000) 알고리즘도 사용가능 2중 for문 가능
- 최초에 priorities의 최대값을 구함 
- 최대값보다 priorities가 작으면 큐에 넣고 크면 프로세스 종료후 최대값 다시 구함

### 💻 풀이 코드
```java
if (max > priority) {
    queue.addLast(idx);
} else {
    answer++;
    max = 0;

    if (location == idx) {
        break;
    }
    priorities[idx] = -1;
    for (int j = 0; j < priorities.length; j++) {
        if(priorities[j] > max) {
            max = priorities[j];
        }
    }
}
```
### 🔁 회고

- queue의 특징을 기억하되 최대한 ArrayDequeue를 사용하자
- 조건 확인을 잘해서 이중 for문 가능 여부를 생각한다면 쉽게 풀리는 문제가 많음


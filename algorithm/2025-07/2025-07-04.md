# ğŸ§  2025-07-04 ì•Œê³ ë¦¬ì¦˜ í’€ì´

## ğŸ“Œ ë¬¸ì œ 1 : [í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 43163] ë‹¨ì–´ ë³€í™˜

### âœ… ë¬¸ì œ ìš”ì•½
- ì‹œì‘ ë‹¨ì–´(`begin`)ì—ì„œ ëª©í‘œ ë‹¨ì–´(`target`)ê¹Œì§€, í•œë²ˆì— **í•˜ë‚˜ì˜ ì•ŒíŒŒë²³**ë§Œ ë°”ê¿”ê°€ë©°, **`words` ë¦¬ìŠ¤íŠ¸ ë‚´ì˜ ë‹¨ì–´ë§Œ ì‚¬ìš©**í•˜ì—¬ ë³€í™˜í•  ìˆ˜ ìˆëŠ” **ìµœì†Œ íšŸìˆ˜**ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œ.


### ğŸ’¡ ì ‘ê·¼ ë°©ì‹

- ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS) ë°©ì‹ìœ¼ë¡œ íƒìƒ‰
- ë‹¨ì–´ë¥¼ í•œ ê¸€ìì”© ë¹„êµí•˜ì—¬ í•˜ë‚˜ë§Œ ë‹¤ë¥¸ ê²½ìš°ë§Œ ë³€í™˜ ê°€ëŠ¥
- ì´ë¯¸ ë°©ë¬¸í•œ ë‹¨ì–´ëŠ” ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ì•Šë„ë¡ `visited[]` ë°°ì—´ì„ ì‚¬ìš©
- `currentWord == target`ì´ë©´ countë¥¼ `answer`ë¡œ ê¸°ë¡

### ğŸ‘£ í’€ì´ ì ˆì°¨


1. `solution()`ì—ì„œ DFSë¥¼ ì‹œì‘í•˜ê³ , `visited` ë°°ì—´ì„ ì´ˆê¸°í™”
2. DFS í•¨ìˆ˜ì—ì„œëŠ” í˜„ì¬ ë‹¨ì–´ê°€ `target`ê³¼ ê°™ë‹¤ë©´ `count`ë¥¼ `answer`ì— ëŒ€ì…
3. `words` ë°°ì—´ì„ ìˆœíšŒí•˜ë©° ë‹¤ìŒ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ë‹¨ì–´ë¥¼ ì°¾ìŒ:
   - ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ê³ 
   - í˜„ì¬ ë‹¨ì–´ì™€ **í•œ ê¸€ìë§Œ ë‹¤ë¦„**
4. ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´:
   - `visited[i] = true` ì²˜ë¦¬ í›„ DFS ì¬ê·€ í˜¸ì¶œ
   - ë°±íŠ¸ë˜í‚¹ì„ ìœ„í•´ DFS ì´í›„ `visited[i] = false` ì²˜ë¦¬

### ğŸ’» í’€ì´ ì½”ë“œ
```java
 int answer = 0;
boolean[] visited;
public int solution(String begin, String target, String[] words) {
    visited = new boolean[words.length];
    dfs(begin, target, 0,  words);
    return answer;
}
    
void dfs(String currentWord, String target, int count, String[] words) {
    if (currentWord.equals(target)) {
        answer =  count;
        return;

    for (int i = 0; i < words.length; i++) {
        int charCnt = 0;
        String word = words[i];
        if (visited[i]) {
            continue;
        }
        for (int j = 0; j < word.length(); j++) {
            if (word.charAt(j) == currentWord.charAt(j)) {
                charCnt++;
            }
        }
        if (charCnt == word.length() - 1) {
            visited[i] = true;
            dfs(word, target, count + 1, words);
            visited[i] = false;
        }
    }
}
```

### ğŸ” ì„±ëŠ¥ ë¶„ì„
- ì‹œê°„ ë³µì¡ë„: O(N * M)
  - Nì€ ë‹¨ì–´ ìˆ˜(words.length), Mì€ ë‹¨ì–´ ê¸¸ì´(word.length())ëª¨ë“  ë‹¨ì–´ì— ëŒ€í•´ ìµœëŒ€ í•œ ë²ˆì”© ë¹„êµí•¨

### ğŸ” íšŒê³ 

- visited[]ë¥¼ ì„ ì–¸í•˜ì§€ ì•Šê³  í’€ë©´ ì¤‘ë³µ ë°©ë¬¸ìœ¼ë¡œ ì¸í•´ ë¬´í•œ ë£¨í”„ê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ
- DFS ë‚´ë¶€ì—ì„œ ë°©ë¬¸ í‘œì‹œì™€ ë°±íŠ¸ë˜í‚¹(visited[i] = false) ìˆœì„œë¥¼ ì •í™•íˆ ì§€í‚¤ëŠ” ê²ƒì´ ì¤‘ìš”
- ë‹¨ì–´ê°„ ë¹„êµëŠ” í•œ ê¸€ì ì°¨ì´ì¼ ë•Œë§Œ ì´ë™ ê°€ëŠ¥í•œì§€ í™•ì¸í•˜ëŠ” í•µì‹¬ ë¡œì§

---




## ğŸ“Œ ë¬¸ì œ 2 : [í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 1844] ê²Œì„ ë§µ ìµœë‹¨ê±°ë¦¬

### âœ… ë¬¸ì œ ìš”ì•½

- ìƒëŒ€ ì§„ì˜ì— ë„ë‹¬í•˜ê¸° ìœ„í•´, 2ì°¨ì› `maps` ë°°ì—´ ë‚´ì—ì„œ ì‹œì‘ì  `(0, 0)`ë¶€í„° ë„ì°©ì  `(N-1, M-1)`ê¹Œì§€ì˜ **ìµœë‹¨ ê±°ë¦¬**ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œ
- ì´ë™ ê°€ëŠ¥í•œ ê²½ë¡œëŠ” `1`, ë¶ˆê°€ëŠ¥í•œ ê²½ë¡œëŠ” `0`ìœ¼ë¡œ ì£¼ì–´ì§


### ğŸ’¡ ì ‘ê·¼ ë°©ì‹

- **ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS)** ë¥¼ í™œìš©í•˜ì—¬ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°
- ë°©ë¬¸ ë…¸ë“œ ê´€ë¦¬ë¥¼ ìœ„í•œ `visited` ë°°ì—´ì„ ì‚¬ìš©
- `Node(x, y, count)` í˜•íƒœë¡œ í˜„ì¬ ì¢Œí‘œì™€ ì´ë™ íšŸìˆ˜ë¥¼ ì €ì¥
- íì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚¼ ë•Œë§ˆë‹¤ ìƒí•˜ì¢Œìš° ë°©í–¥ìœ¼ë¡œ ì´ë™ ê°€ëŠ¥í•œì§€ ì²´í¬í•˜ê³ , ë„ì°©ì ì— ë„ë‹¬í•˜ë©´ íƒìƒ‰ ì¢…ë£Œ

### ğŸ‘£ í’€ì´ ì ˆì°¨

1. ì¶œë°œì  `(0, 0)`ì„ íì— ì‚½ì…í•˜ê³ , ë°©ë¬¸ ì²˜ë¦¬
2. íì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚´ë©° 4ë°©í–¥ íƒìƒ‰(dx/dy ë°°ì—´ ì‚¬ìš©)
3. ë‹¤ìŒ ì¢Œí‘œê°€ ë§µ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šê³ , ë°©ë¬¸í•˜ì§€ ì•Šì•˜ìœ¼ë©° ê°’ì´ `1`ì´ë©´ íì— ì‚½ì…
4. íì— ì‚½ì…í•  ë•Œ ì´ë™ ê±°ë¦¬ `+1`ì„ í•¨ê»˜ ì „ë‹¬
5. ë„ì°©ì ì— ë„ë‹¬í•˜ë©´ í•´ë‹¹ ê±°ë¦¬ë¡œ ì¢…ë£Œ

### ğŸ’» í’€ì´ ì½”ë“œ
```java
public int solution(int[][] maps) {
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};
    int answer = -1;
    Queue<Node> queue = new LinkedList<>();
    queue.offer(new Node(0, 0, 1));
    boolean[][] visited = new boolean[maps.length][maps[0].length];
    visited[0][0] = true;
    while (!queue.isEmpty()) {
        Node currentNode = queue.poll();
        int curX = currentNode.x;
        int curY = currentNode.y;
        int curCount = currentNode.count;
        if (curX == maps.length - 1 && curY == maps[0].length - 1) {
            answer = curCount;
            break;
        }
        for (int i = 0; i < dx.length; i++) {
            int nextX = curX + dx[i];
            int nextY = curY + dy[i];
            if (nextX < 0 || nextY < 0 || nextX >= maps.length || nextY >= maps[0].length) {
                continue;
            }
            if (visited[nextX][nextY]) {
                continue;
            }
            if (maps[nextX][nextY] == 0) {
                continue;
            }
            visited[nextX][nextY] = true;
            queue.offer(new Node(nextX, nextY, curCount + 1));
        }
    }
    return answer;
}

class Node {
    int x;
    int y;
    int count;
    Node(int x, int y, int count) {
        this.x = x;
        this.y = y;
        this.count = count;
    }
}
```

### ğŸ” ì„±ëŠ¥ ë¶„ì„
- O(N Ã— M)
    - ë§µ ì „ì²´ë¥¼ í•œ ë²ˆì”© íƒìƒ‰í•˜ë¯€ë¡œ, Nì€ í–‰ì˜ ìˆ˜, Mì€ ì—´ì˜ ìˆ˜

### ğŸ” íšŒê³ 

- ë°©ë¬¸ ì—¬ë¶€ë¥¼ poll ì‹œì ì´ ì•„ë‹ˆë¼ offer ì‹œì ì— ì²˜ë¦¬í•´ì•¼ ì¤‘ë³µ ë°©ë¬¸ì„ ë°©ì§€í•˜ê³  ì„±ëŠ¥ì´ ì¢‹ì•„ì§
- DFSê°€ ì•„ë‹Œ BFSë¥¼ ì‚¬ìš©í•´ì•¼ ìµœë‹¨ ê±°ë¦¬ ë³´ì¥
- Node ê°ì²´ë¥¼ ë³„ë„ë¡œ ì •ì˜í•¨ìœ¼ë¡œì¨ countë¥¼ ì¶”ì í•˜ê¸° ì‰¬ì›Œì§

---




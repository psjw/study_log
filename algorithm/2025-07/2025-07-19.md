# 🧠 2025-07-12 알고리즘 풀이


## 📌 문제 1 : [백준 11403] 경로 찾기

### ✅ 문제 요약

- **가중치가 없는 방향 그래프**가 주어졌을 때, **정점 i에서 정점 j로 가는 경로가 존재하는지 여부**를 모든 쌍에 대해 출력
- 경로가 존재하면 `1`, 존재하지 않으면 `0`을 출력

### 💡 접근 방식

- **플로이드-워셜 알고리즘**을 이용하여 해결
- 간선의 존재 여부(`0` 또는 `1`)만을 활용하므로  
  거리 계산이 아닌 **도달 가능 여부 판단**에 집중
- `dist[i][j] = 1` if `dist[i][k] == 1 && dist[k][j] == 1`

### 👣 풀이 절차

1. 인접 행렬을 입력 받아 초기 상태 구성
2. 3중 루프(`k → i → j`)를 통해 중간 노드를 경유한 경우의 연결 여부 확인
3. 연결이 가능하다면 `dist[i][j] = 1`로 갱신
4. 결과 행렬을 출력

### 💻 풀이 코드
```java
int[][] dist = new int[N][N];

// 입력: 인접 행렬 구성
for (int i = 0; i < N; i++) {
    StringTokenizer st = new StringTokenizer(br.readLine());
    for (int j = 0; j < N; j++) {
        dist[i][j] = Integer.parseInt(st.nextToken());
    }
}

// 플로이드-워셜 알고리즘 수행
for (int k = 0; k < N; k++) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (dist[i][k] == 1 && dist[k][j] == 1) {
                dist[i][j] = 1;
            }
        }
    }
}

// 출력
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        bw.write(dist[i][j] + " ");
    }
    bw.newLine();
}
bw.flush();
```

### 🔍 성능 분석
- 시간 복잡도 : O(N³) (3중 for문)


### 🔁 회고

- 해당 문제는 **최단 거리 계산이 아닌 단순 도달 여부** 판단이므로 일반적인 플로이드-워셜의 구조에서 거리 계산 부분만 생략한 버전으로 해결 가능
- 문제에서 요구하는 결과가 Boolean이기 때문에 dist[i][j] 값을 1 또는 0로만 유지하면서 처리하는 것이 핵심
- 사이클 여부, 가중치 고려 등은 필요 없는 단순 경로 연결 여부 문제라는 점에서 플로이드-워셜의 구조적 이해도를 높이기에 적합한 문제

---



## 📌 문제 2 : [프로그래머스 49191] 순위

### ✅ 문제 요약

- 총 `n`명의 권투 선수가 있고, 일부 선수들 간의 **1:1 경기 결과**가 주어짐
- 주어진 결과만으로 정확한 순위를 알 수 있는 선수의 **총 수**를 구하는 문제


### 💡 접근 방식

- **플로이드-워셜 알고리즘**을 이용하여 간접적인 승패 관계를 유추
- `fight[i][j] = 1` → i가 j를 이김  
  `fight[i][j] = -1` → i가 j에게 짐  
  `fight[i][j] = 0` → 관계를 모름
- 모든 선수 간의 관계가 `n-1`개로 확정된 경우 해당 선수의 순위도 확정 가능

### 👣 풀이 절차

1. `fight[][]` 배열에 직접 승패 정보를 기록  
   → `fight[a][b] = 1`, `fight[b][a] = -1`

2. `k → s → e` 순서로 순회하며 간접 관계 추론  
   - `fight[s][k] == 1 && fight[k][e] == 1`이면 `fight[s][e] = 1`, `fight[e][s] = -1`  
   - `fight[s][k] == -1 && fight[k][e] == -1`이면 `fight[s][e] = -1`, `fight[e][s] = 1`

3. 각 선수별로 자신을 제외한 `n-1명`과의 관계가 모두 확인되었는지 검사  
   → 모두 확인되었으면 해당 선수는 순위 확정

### 💻 풀이 코드
```java
int answer = 0;
int fight[][] = new int[n+1][n+1];

// 초기 경기 결과 입력        
for (int i = 0; i < results.length; i++) {
    int x = results[i][0];
    int y = results[i][1];
    fight[x][y] = 1; //승리
    fight[y][x] = -1; //패배
}

// 플로이드-워셜 알고리즘 활용
for (int k = 1; k <= n; k++) {
    for (int s = 1; s <= n; s++) {
        for (int e = 1; e <= n; e++) {
            if (fight[s][k] == 1 && fight[k][e] == 1) { //승리
                fight[s][e] = 1;
                fight[e][s] = -1;
            }
            if(fight[s][k] == -1 && fight[k][e] == -1) { //패배
                fight[s][e] = -1;
                fight[e][s] = 1;
            }
        }
    }
}

// 순위 계산
for (int i = 1; i <= n; i++) {
    int count = 0;
    for (int j = 1; j <= n; j++) {
        if(fight[i][j] != 0) {
            count++;
        }
    }
    if(count == n-1) {
        answer++;
    }
}

return answer;
```

### 🔍 성능 분석
- 시간 복잡도 : O(N³) (3중 for문)

### 🔁 회고

- 관계 추론 문제에 **플로이드-워셜** 알고리즘을 잘 응용한 대표 예시
- 이 문제는 단순한 승패 비교가 아닌, **간접적인 관계를 얼마나 명확하게 추론할 수 있는지**를 판단하는 것이 핵심
- 1:1 관계를 통해 전체 네트워크가 연결되면 순위 판별이 가능하다는 점을 잘 활용하면 좋음
- 그래프 기반 문제에서 **Boolean 또는 상태**(1, -1, 0)로 상태를 표현하면 분기 처리가 명확해짐

---


# 🧠 2025-08-04 알고리즘 풀이

## 📌 문제 1 : [프로그래머스 42576] 완주하지 못한 선수

### ✅ 문제 요약
- 마라톤에 참가한 선수 목록 `participant`와 완주한 선수 목록 `completion`이 주어졌을 때, **완주하지 못한 선수의 이름을 반환**하는 문제.

### 💡 접근 방식
- `HashMap`을 사용하여 **완주한 선수의 이름과 인원 수를 기록**.
- `participant`를 순회하면서 해당 이름이 `Map`에 있고 값이 1 이상이면 **값을 1 감소**.
- 만약 값이 0이거나 `Map`에 없으면 해당 이름이 완주하지 못한 선수이므로 반환.

### 👣 풀이 절차
1. `HashMap<String, Integer>` 선언.
2. `completion` 배열을 순회하며, 선수 이름을 key, 출현 횟수를 value로 저장 (`getOrDefault` 활용).
3. `participant` 배열을 순회하며:
   - 이름이 `Map`에 존재하고 값이 1 이상이면 값에서 1을 뺌.
   - 그렇지 않으면 해당 이름을 반환.
4. 모든 반복이 끝나면 빈 문자열 반환(논리적으로는 도달하지 않음).

### 💻 풀이 코드
```java
HashMap<String, Integer> map = new HashMap<>();

// 완주한 선수 기록
for (String c : completion) {
    map.put(c, map.getOrDefault(c, 0) + 1);
}

// 참가자 중 완주하지 못한 선수 찾기
for (String p : participant) {
    if (map.containsKey(p) && map.get(p) > 0) {
        map.put(p, map.get(p) - 1);
    } else {
        return p; // 완주 실패자
    }
}

return "";
```

### 🔍 성능 분석
- **시간 복잡도**: O(N)
    - completion 순회: O(N)
    - participant 순회: O(N)
    - 전체: O(N)


### 🔁 회고
- Map을 활용하면 **중복된 이름 처리**가 자연스럽게 가능.
- containsKey와 getOrDefault 조합을 익숙하게 사용하면 코드를 단순화할 수 있음.
- 논리상 return ""까지 도달하지 않지만, 자바 문법상 반환값이 필요하므로 작성.
- 추가 개선: containsKey 없이 getOrDefault만으로 조건 분기를 단순화 가능.

---

## 📌 문제 2 : [프로그래머스 42578] 의상

### ✅ 문제 요약
- 여러 종류의 의상(예: 얼굴, 상의, 하의, 겉옷)이 주어지고, 각 종류에서 1가지 의상만 착용할 수 있을 때 **총 조합 경우의 수**를 구하는 문제.
- 단, **아무것도 입지 않는 경우**는 제외.

### 💡 접근 방식
- `HashMap`을 사용하여 **의상 종류별 개수**를 저장.
- 각 종류별로 "입지 않는 경우"를 고려하여 개수에 **+1**을 더함.
- 모든 종류에 대해 곱셈을 수행해 전체 조합 수를 계산.
- 마지막에 **아무것도 입지 않는 경우(1)**를 빼줌.

### 👣 풀이 절차
1. `HashMap<String, Integer>`를 선언.
2. `clothes` 배열을 순회하며 **의상 종류**를 key, 개수를 value로 저장 (`getOrDefault` 활용).
3. `map.values()`를 순회하며 각 값에 +1을 한 뒤 모두 곱해줌.
4. 곱한 값에서 1을 빼 반환.

### 💻 풀이 코드
```java
Map<String, Integer> map = new HashMap<>();  
int answer = 1;  

// 의상 종류별 개수 저장
for (String[] cloth : clothes) {  
    String clothType = cloth[1];  
    map.put(clothType,map.getOrDefault(clothType,0) + 1);  
}  

// 각 종류별 (입지 않는 경우 포함) 곱셈
Iterator<Integer> it = map.values().iterator();  
while (it.hasNext()) {  
    answer *= it.next() + 1;  
}  

// 아무것도 입지 않는 경우 제외
return answer - 1;
```

### 🔍 성능 분석
- **시간 복잡도**: O(N)
    - 의상 목록 순회: O(N)
    - 종류별 개수 순회: O(K) (K = 의상 종류 수, K ≤ N)
    - 전체: O(N)

### 🔁 회고
- 곱셈 계산 시 “입지 않는 경우”를 포함해야 하기 때문에 **각 종류별 개수에 +1**을 하는 것이 핵심.
- 마지막에 **아무것도 입지 않는 경우**를 제외해야 함을 놓치면 오답 발생.
- Iterator를 사용할 수도 있지만, for-each로 map.values()를 순회하는 것이 더 간결.
- 만약 의상 종류가 많고 조합 수가 매우 커질 수 있다면, **long 타입**을 사용하여 오버플로우 방지 필요.

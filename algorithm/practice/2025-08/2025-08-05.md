# 🧠 2025-08-05 알고리즘 풀이

## 📌 문제 1 : [프로그래머스 42840] 모의고사

### ✅ 문제 요약
- 수포자 3인방은 각각 특정한 패턴으로 문제를 찍음
- 주어진 정답 배열(answers)에 대해 **가장 많이 정답을 맞힌 사람**을 찾아 **오름차순으로 반환**

### 💡 접근 방식
- 각 수포자의 찍는 패턴을 배열로 선언
- 정답 배열을 순회하면서, 각 수포자의 패턴과 비교하여 맞춘 개수를 카운트
- `HashMap<Integer, Integer>`을 사용하여 수포자 번호를 key, 맞춘 개수를 value로 저장
- 가장 높은 점수를 받은 수포자들을 리스트로 모아 반환

### 👣 풀이 절차
1. 수포자 3인의 정답 패턴을 각각 배열로 선언
2. answers 배열을 순회하며 각 수포자의 정답 패턴과 비교
   - `i % pattern.length`를 통해 반복 패턴 순환 처리
3. 정답이 일치할 경우, 해당 수포자의 점수를 map에 누적
4. map에서 최대 점수를 추출
5. 최대 점수와 같은 값을 가진 수포자의 번호를 리스트로 수집 후 반환

### 💻 풀이 코드
```java
private static int[] solution(int[] answers) {
    int[] one = new int[]{1, 2, 3, 4, 5};
    int[] two = new int[]{2, 1, 2, 3, 2, 4, 2, 5};
    int[] three = new int[]{3, 3, 1, 1, 2, 2, 4, 4, 5, 5};

    HashMap<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < answers.length; i++) {
        if (one[i % one.length] == answers[i]) {
            map.put(1, map.getOrDefault(1, 0) + 1);
        }
        if (two[i % two.length] == answers[i]) {
            map.put(2, map.getOrDefault(2, 0) + 1);
        }
        if (three[i % three.length] == answers[i]) {
            map.put(3, map.getOrDefault(3, 0) + 1);
        }
    }

    int max = map.values().stream().mapToInt(x -> x).max().getAsInt();

    return map.entrySet().stream()
            .filter(x -> x.getValue() == max)
            .mapToInt(Map.Entry::getKey)
            .sorted()
            .toArray();
}
```

### 🔍 성능 분석
- **시간 복잡도**: O(N)
    - answers 순회: O(N)
    - 전체: O(N)
> ※ N: answers 배열 길이 (최대 10,000)

### 🔁 회고
- 핵심은 **수포자 패턴의 순환**을 % 연산으로 처리하는 부분
- 각 수포자의 정답 비교를 위해 패턴 배열 길이보다 큰 answers에 대응하려면 i % 패턴길이를 사용
- HashMap으로 점수를 관리하면 동적으로 수포자 수가 늘어나는 상황에도 확장 가능
- 최종 반환 시 오름차순 정렬이 요구되므로 .sorted()가 필요

---

## 📌 문제 2 : [프로그래머스 12949]  행렬의 곱셈

### ✅ 문제 요약
- 두 개의 2차원 행렬 `arr1`, `arr2`가 주어질 때, **행렬 곱셈의 결과**를 구하여 반환하는 문제
- `arr1`의 크기: (a × b), `arr2`의 크기: (b × c)라면, 결과 행렬의 크기는 (a × c)

### 💡 접근 방식
- **행렬 곱셈의 정의**에 따라 3중 반복문을 사용하여 구현
- 결과 행렬의 각 원소 `[i][j]`는 `arr1`의 i번째 행과 `arr2`의 j번째 열의 **내적**으로 계산
- `arr1[i][k] * arr2[k][j]` 값을 누적하여 `answer[i][j]`에 더함

### 👣 풀이 절차
1. 결과 행렬 `answer`를 `(arr1.length × arr2[0].length)` 크기로 초기화
2. 반복문을 3중으로 순회:
   - `i`: 행렬 1의 행
   - `j`: 행렬 2의 열
   - `k`: 공통된 곱셈 축 (arr1의 열 = arr2의 행)
3. `answer[i][j] += arr1[i][k] * arr2[k][j]` 방식으로 누적 곱셈 수행
4. 최종적으로 `answer` 반환

### 💻 풀이 코드
```java
public static int[][] solution(int[][] arr1, int[][] arr2) {
    int[][] answer = new int[arr1.length][arr2[0].length];

	for (int i = 0; i < arr1.length; i++) {
        for (int j = 0; j < arr2[0].length; j++) {
            for (int k = 0; k < arr1[0].length; k++) {
                answer[i][j] += arr1[i][k] * arr2[k][j];
            }
        }
    }

    return answer;
}
```

### 🔍 성능 분석
- **시간 복잡도**: O(nmk)
    - 3중 for 루프: O(n × m × k)
	    - n : arr1행의 개수
	    - m : arr1 열의 개수 / arr2 행 개수
	    - k : arr2 열개수

### 🔁 회고
- 이 문제는 **기초적인 행렬 연산을 구현할 수 있는지 확인**하는 문제로, 3중 루프 구조에 익숙해질 수 있음
- 결과 행렬의 크기가 (arr1의 행 개수 × arr2의 열 개수)라는 점을 실수하지 않도록 주의
- Java에서는 2차원 배열의 크기를 정확하게 선언하고, arr1[0].length, arr2[0].length 사용에 익숙해질 필요 있음
- **코드 최적화보다는 개념을 정확히 구현**하는 것이 우선